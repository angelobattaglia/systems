{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Process_ID/","title":"Process ID","text":"<p>Certainly! Let's break down the concepts presented clearly and concisely:</p>"},{"location":"Process_ID/#1-uid-and-gid","title":"1. UID and GID","text":"<ul> <li>UID (User ID): Identifies a user uniquely on a Unix/Linux system.</li> <li>GID (Group ID): Identifies the user's primary group on the system.</li> </ul> <p>The functions:</p> <pre><code>uid_t getuid();\ngid_t getgid();\n</code></pre> <p>These retrieve the real user ID and real group ID of the process, respectively. The \"real\" IDs typically represent the user who initiated the process.</p>"},{"location":"Process_ID/#2-effective-uid-and-effective-gid","title":"2. Effective UID and Effective GID","text":"<p>In addition to the real IDs, processes have an Effective UID (EUID) and Effective GID (EGID).</p> <ul> <li>Effective UID (EUID) determines the permissions for file access and actions the process can perform.</li> <li>Effective GID (EGID) affects group-level permissions.</li> </ul> <p>The functions:</p> <pre><code>uid_t geteuid();\ngid_t getegid();\n</code></pre> <p>retrieve the effective user and group IDs, respectively.</p>"},{"location":"Process_ID/#3-practical-example-passwd-command","title":"3. Practical Example (passwd Command)","text":"<p>A typical example of this mechanism is the <code>passwd</code> command:</p> <ul> <li>Changing a user's password involves modifying sensitive system files, which typically only root can access.</li> <li>The <code>passwd</code> command needs temporary elevated permissions to perform this task, even if executed by a regular user.</li> <li>Therefore, <code>passwd</code> has the SetUID bit set. When executed, the operating system temporarily grants the command the Effective UID of the file's owner (usually root).</li> <li>Consequently, even though the Real UID remains the user running the command, the Effective UID is temporarily elevated to root to complete the task.</li> </ul> <p>Example scenario: - Normal user executes: <code>passwd</code> - System recognizes the SetUID bit on <code>/usr/bin/passwd</code> - Temporarily elevates the command\u2019s Effective UID to root. - Command runs with root permissions to change the password. - After execution, privileges are dropped back to normal user levels.</p>"},{"location":"Process_ID/#in-short","title":"In Short:","text":"<ul> <li>UID/GID \u2192 identity of the user/process.</li> <li>Effective UID/GID \u2192 permissions a process uses to interact with system resources.</li> <li>SetUID/SetGID bit \u2192 allows temporary privilege elevation, crucial for secure system operations.</li> </ul> <p>This mechanism is key to balancing security and usability in Unix/Linux systems.</p>"},{"location":"Process_ID/#operative-example","title":"Operative Example","text":"<p>This output</p> <pre><code>Process ID (PID): 22153\nParent Process ID (PPID): 21767\nUser ID (UID): 1000\nGroup ID (GID): 1000\nEffective User ID (EUID): 1000\nEffective Group ID (EGID): 1000\n</code></pre> <p>means</p> <pre><code>Explanation of your output:\nPID (Process ID):\n22153 is the unique identifier assigned by the system to your running process.\n\nPPID (Parent Process ID):\n21767 identifies the parent process which launched your current program (often your shell, IDE, or terminal).\n\nUser ID (UID):\n1000 usually indicates a standard, non-root user account (the first user account created in a Unix/Linux system is commonly assigned UID 1000).\n\nGroup ID (GID):\n1000 is your default user group, typically matching your UID.\n\nEffective User ID (EUID) and Effective Group ID (EGID):\nBoth 1000, indicating that no special privileges or changes to identity have been made to your program at this point.\n</code></pre>"},{"location":"command_line/","title":"Commands","text":""},{"location":"command_line/#the-diff-command","title":"The diff command","text":""},{"location":"command_line/#hard-links-and-soft-links","title":"Hard Links and Soft Links","text":"<p>The <code>ln</code> command allows to create hard and soft links.</p>"},{"location":"command_line/#copy-a-directory-tree-recursively","title":"Copy a directory tree recursively","text":"<pre><code>cp -r ~/soEx01 ~/soEx01backup # copy it recursively\nrm -r ~/soEx01 # remove it recursively\n</code></pre>"},{"location":"command_line/#wc-word-count-command","title":"wc (word count) command","text":"<p><code>wc</code> prints the number of rows, words, and characters of the file passed as argument, respectively</p> <pre><code>wc lab01e01in.txt \n100  467 3114 lab01e01in.txt\n</code></pre>"},{"location":"command_line/#the-history","title":"The history","text":"<p>Prints the last commands executed in the terminal</p> <pre><code>history\n</code></pre>"},{"location":"command_line/#permission-management","title":"Permission Management","text":""},{"location":"command_line/#verifying-your-username-and-group","title":"Verifying Your Username and Group","text":"<p>To check your username and group, use the following commands:</p> <ul> <li> <p><code>who</code> Command: Displays your login name and other session information.   <code>shell   who</code></p> </li> <li> <p><code>groups</code> Command: Shows the groups you belong to.   <code>shell   groups</code></p> </li> </ul> <p>Is it possible to modify them? Yes, it is possible to modify your username or group if you have the required administrative rights.  For example, a user with root privileges can use the <code>usermod</code> command to change a username or group.</p> <p>Example:</p> <pre><code>sudo usermod -l new_username old_username\nsudo usermod -g new_group username\n</code></pre>"},{"location":"command_line/#checking-permissions-on-directories","title":"Checking Permissions on Directories","text":"<p>To check the read, write, and execute permissions on various directories, use the following command:</p> <pre><code>ls -l /home\n</code></pre> <p>This will show you a detailed list of directories in /home with their permissions, owners, and groups. For example:</p> <pre><code>drwxr-xr-x  2 user1 user1 4096 Dec  4 10:00 user1\n</code></pre> <ul> <li>The first column shows the permissions (drwxr-xr-x).</li> <li>The second column shows the owner (user1).</li> <li>The third column shows the group (user1).</li> </ul> <p>To see the permissions for a specific directory or file, use:</p> <pre><code>ls -l /home/user1\n</code></pre> <p>This will list the permissions, owner, and group for files and directories within /home/user1.</p>"},{"location":"file_system/","title":"File system","text":"<p>Information Storage</p> <p>Information is preserved over extended periods, remaining unaffected by: 1. Program or process termination. 2. Loss of power supply or other disruptions. 3. Logical Perspective on Files</p> <p>A file is: 1. A structured collection of related data, encompassing elements such as numbers, text, images, and more. 2. Data stored on electronic devices using standardized encoding systems. 3. Represented in a contiguous address space within the storage medium.</p> <p>ASCII encoding De-facto standard \u27a2 ASCII, American Standard Code for Information Interchange 128 total characters 32 not printable 96 printable \u25aa Originally based on the English alphabet \u25aa 128 characters are coded in 7-bit (binary numbers) \u27a2 Extended ASCII (or high ASCII) \u25aa Extension of ASCII to 8-bit and 255 characters \u25aa Several versions exist \u25cf ISO 8859-1 (ISO Latin-1), ISO 8859-2 (Eastern European languages), ISO 8859-5 for Cyrillic languages, etc.</p> <p>Unicode encoding \u2756 Industrial standard that includes the alphabets for any existing writing system \u27a2 It contains more 110,000 characters \u27a2 It includes more than 100 sets of symbols \u2756 Several implementations exist \u27a2 UCS (Universal Character Set) \u27a2 UTF (Unicode Tranformation Format) \u25aa UTF-8, groups of 8 bits size (1, 2, 3 or 4 groups) \u25cf ASCII coded in the first 8 bits \u25aa UTF-16, groups of 16 bits size (1 or 2 groups) \u25aa UTF-32, groups of 32 bits size (fixed length)</p>"},{"location":"file_system/#textual-and-binary-files","title":"Textual and binary files","text":"<p>A file is basically a sequence of bytes written one after the other. Each byte includes 8 bits, with possible values 0 or 1. As a consequence all files are binary.  Normally we can distinguish between: 1. Textual files (or ASCII) (C sources, C++ sources etc..) 2. Binary files (Executables, Word, Excel ..)</p>"},{"location":"file_system/#remark","title":"Remark:","text":"<p>The UNIX/Linux kernel does not distinguish between binary and textual files.</p>"},{"location":"file_system/#textual-files-or-ascii-to-give-to-chatgpt-for-better-explaination","title":"Textual files (or ASCII) (to give to chatGPT for better explaination)","text":"<p>\u2756 Files consisting of data encoded in ASCII \u27a2 Sequence of 0 and 1, which (in groups of 8 bit) codify ASCII symbols \u2756 Textual files are usually \u201cline-oriented\u201d \u27a2 Newline: go to the next line \u25aa UNIX/Linux and Mac OSX \u25cf Newline = 1 character \u25cf Line Feed (go to next line, LF, 10 10) \u25aa Windows \u25cf Newline = 2 characters \u25cf Line Feed (go to next line, LF, 10 10) + Carriage Return (go to beginning of the line, CR, 13 10)</p>"},{"location":"file_system/#binary-files","title":"Binary Files","text":"<p>\u2756 A binary file is a sequence of 0 and 1, not \u201cbyte-oriented\u201d, meaning it's bit by bit, not byte by byte \u2756 The smallest unit that can be read/write is the bit \u27a2 Non easy the management of the single bit \u27a2 They usually include every possible sequence of 8 bits, which do not necessarily correspond to printable characters, new-line, etc.</p>"},{"location":"file_system/#why-are-binary-files-used","title":"Why are binary files used?","text":"<p>\u2756 Advantages \u27a2 Compactness (smaller average dimension) \u25aa Examples: Number 10000010 occupies 6 characters, (i.e., 6 bytes) in the Text/ASCII format, and 4 bytes if coded in an integer (short) \u27a2 Ease of editing the file \u25aa An integer always occupies the same space \u27a2 Ease of positioning on the file \u25aa Fixed record structure \u2756 Drawbacks \u27a2 Limited portability \u27a2 Impossibility to use a standard editor</p>"},{"location":"file_system/#why-are-binary-files-used_1","title":"Why are binary files used?","text":"<p>\u2756 Advantages \u27a2 Compactness (smaller average dimension) \u25aa Examples: Number 10000010 occupies 6 characters, (i.e., 6 bytes) in the Text/ASCII format, and 4 bytes if coded in an integer (short) \u27a2 Ease of editing the file \u25aa An integer always occupies the same space \u27a2 Ease of positioning on the file \u25aa Fixed record structure \u2756 Drawbacks \u27a2 Limited portability \u27a2 Impossibility to use a standard editor</p>"},{"location":"file_system/#serialization","title":"Serialization","text":"<p>Definition: Serialization is the process of converting a data structure (e.g., a <code>struct</code> in C) into a format that can be stored or transmitted and later reconstructed in its original form. </p> <ul> <li>Purpose: </li> <li>Allows a data structure to be stored (e.g., in a file or database)   or transmitted (e.g., over a network) as a single entity.  </li> <li>The serialized data is read and reconstructed according to the same   serialization format, ensuring the original structure is replicated.</li> </ul> <p>Features:   - Most programming languages support serialization using read/write      (R/W) operations on files. Examples include:   - Java   - Python   - Objective-C   - Ruby  </p>"},{"location":"file_system/#example-of-serialization-in-c","title":"Example of Serialization in C","text":"<p>Structure Definition:</p> <pre><code>struct mys {\n    int id;\n    long int rn;\n    char n[L], c[L];\n    int mark;\n} s;\n</code></pre> <p>Serialization Formats: 1. Binary Serialization:    - The structure is stored as a sequence of bytes.    - The interpretation depends on the encoding scheme (e.g., ASCII on 8 bits or Unicode on 16 bits).    - The file size is compact but not human-readable.</p> <ol> <li>Text Serialization: </li> <li>Each field is stored as text, using character encoding (e.g., ASCII on 8 bits).  </li> <li>Example: <code>1 100000 Romano Antonio 25</code></li> <li>Larger file size compared to binary serialization but more human-readable.  </li> </ol>"},{"location":"file_system/#notes","title":"Notes:","text":"<ul> <li>Serialization formats affect file size and readability:  </li> <li>Binary formats are compact but require decoding.  </li> <li>Text formats are larger but easy to interpret.  </li> <li>Incorrect encoding or decoding can result in malformed data (e.g., corrupted text with unrecognized characters).</li> </ul>"},{"location":"file_system/#io-with-the-c-standard-library","title":"I/O with the C standard library","text":"<p>I/O operations with ANSI C can be performed through different categories of functions 1. Character by character 2. Row by row 3. Formatted I/O 4. Binary I/O Read examples Write examples Binary I/O examples</p>"},{"location":"file_system/#iso-c-standard-library","title":"ISO C Standard Library","text":"<p>Standard I/O is \u201cfully buffered\u201d \u27a2 The I/O operation is performed only when the I/O buffer is full \u27a2 The \u201cflush\u201d operation indicates the actual write of the buffer to the I/O</p> <pre><code>#include &lt;stdio.h&gt;\nvoid setbuf (FILE *fp, char *buf);\nint fflush (FILE *fp);\n</code></pre> <p>Standard error is never buffered. For concurrent processes, use:</p> <pre><code>setbuf (stdout, 0);\nfflush (stdout);\n</code></pre>"},{"location":"file_system/#open-and-close-a-file","title":"Open and close a file","text":"<p>Here's how to open and close a file</p> <pre><code>#include &lt;stdio.h&gt;\nFILE *fopen (char *path, char *type);\nFILE *fclose (FILE *fp);\n</code></pre>"},{"location":"file_system/#access-methods","title":"Access methods","text":"<ul> <li>r, rb, w, wb, a, ab r+, r+b, etc.</li> <li>The UNIX kernel does not make any difference between textual files (ASCII) and binary files</li> <li>The \u201cb\u201d option has no effect, e.g. \u201cr\u201d==\u201crb\u201d, \u201cw\u201d==\u201cwb\u201d, etc.</li> </ul>"},{"location":"file_system/#io-character-by-character","title":"I/O character by character","text":"<pre><code>#include &lt;stdio.h&gt;\nint getc (FILE *fp);\nint fgetc (FILE *fp);\nint putc (int c, FILE *fp);\nint fputc (int c, FILE *fp);\n</code></pre> <p>\u2756 Returned values \u27a2 A character on success \u27a2 EOF on error, or when the end of the file is reached \u2756 The function \u27a2 getchar is equivalent to getc (stdin) \u27a2 putchar is equivalent to putc (c, stdout)</p>"},{"location":"file_system/#io-row-by-row","title":"I/O row by row","text":"<pre><code>#include &lt;stdio.h&gt;\nchar *gets (char *buf);\nchar *fgets (char *buf, int n, FILE *fp);\nint puts (char *buf);\nint fputs (char *buf, FILE *fp);\n</code></pre> <p>\u2756 Returned values \u27a2 buf (gets/fgets), or a non-negative value (puts/fputs) in the case of success \u27a2 NULL (gets/fgets), or EOF for errors or when the end of file is reached (puts/fputs) \u2756 Lines must be delimited by \"new-line\"</p>"},{"location":"file_system/#formatted-io","title":"Formatted I/O","text":"<pre><code>#include &lt;stdio.h&gt;\nint scanf (char format, ...);\nint fscanf (FILE *fp, char format, ...);\nint printf (char format, ...);\nint fprintf (FILE *fp, char format, ...);\n</code></pre> <p>\u2756 High flexibility in data manipulation \u27a2 Formats (characters, integers, reals, etc.) \u27a2 Conversions</p>"},{"location":"file_system/#binary-io","title":"Binary I/O","text":"<pre><code>#include &lt;stdio.h&gt;\nsize_t fread (void *ptr, size_t size,\nsize_t nObj, FILE *fp);\n\nsize_t fwrite (void *ptr, size_t size,\nsize_t nObj, FILE *fp);\n</code></pre> <p>Each I/O operation (single) operates on an aggregate object of specific size aggregate object of specific size all the fields of the struct \u27a2 With gets/puts it is not possible, because both would terminate on NULL bytes or new-lines \u2756 Returned values \u27a2 Number of objects written/read \u27a2 If the returned value does not correspond to the ferror and feof can be parameter nObj used to distinguish  \u25aa An error has occurred between the two cases  \u25aa The end of file has been reached \u2756 Often used to manage binary files \u27a2 serialized R/W (single operation for the whole struct) \u27a2 Potential problems in managing different architectures \u25aa Data format compatibility (e.g., integers, reals, etc.) \u25aa Different offsets for the fields of the struct</p>"},{"location":"file_system/#posix-standard-library-of-sys-calls","title":"POSIX Standard Library of sys calls","text":"<p>I/O in UNIX can be entirely performed with only 5 functions - open, read, write, lseek, close \u2756 This type of access \u27a2 Is part of POSIX and of the Single UNIX Specification, but not of ISO C \u27a2 It is normally defined with the term \"unbuffered I/O\", in the sense that each read or write operation corresponds to a system call</p>"},{"location":"file_system/#system-call-open","title":"System call open()","text":"<p>\u2756 In the UNIX kernel a \"file descriptor\" is a non-negative integer \u2756 Conventionally (also for shells) \u27a2 Standard input \u25aa 0 = STDIN_FILENO \u27a2 Standard output \u25aa 1 = STDOUT_FILENO \u27a2 Standard error \u25aa 2 = STDERR_FILENO These descriptors are defined in the headers file unistd.h</p>"},{"location":"file_system/#system-call-open_1","title":"System call open()","text":""},{"location":"file_system/#include","title":"include","text":""},{"location":"file_system/#include_1","title":"include","text":""},{"location":"file_system/#include_2","title":"include  <p>int open (const char path, int flags); int open (const char path, int flags, mode_t mode); \u2756 It opens a file defining the permissions \u2756 Returned values \u27a2 The descriptor of the file on success \u27a2 -1 on error</p>","text":""},{"location":"file_system/#system-call-open_2","title":"System call open()","text":"<p>\u2756 It can have 2 or 3 parameters \u27a2 The mode parameter is optional \u2756 Path indicates the file to open \u2756 Flags has multiple options int open ( const char *path, int flags, mode_t mode ); \u27a2 Can be obtained with the OR bit-by-bit of constants defined in the header file fcntl.h \u27a2 One of the following three constants is mandatory \u25aa O_RDONLY \u25aa O_WRONLY \u25aa O_RDWR open for read-only access open for write-only access open for read-write access</p>"},{"location":"file_system/#system-call-open_3","title":"System call open()","text":"<p>\u27a2 Optional constants \u25aa O_CREAT \u25aa O_EXCL \u25aa O_TRUNC \u25aa O_APPEND \u25aa O_SYNC \u25aa ... int open ( const char *path, int flags, mode_t mode ); creates the files if not exist error if O_CREAT is set and the file exists remove the content of the file append to the file each write waits that the physical write operation is finished before continuing</p>"},{"location":"file_system/#system-call-open_4","title":"System call open()","text":"<p>\u27a2 Optional constants \u25aa O_CREAT \u25aa O_EXCL \u25aa O_TRUNC \u25aa O_APPEND \u25aa O_SYNC \u25aa ... int open ( const char *path, int flags, mode_t mode ); creates the files if not exist error if O_CREAT is set and the file exists remove the content of the file append to the file each write waits that the physical write operation is finished before continuing</p>"},{"location":"file_system/#system-call-read","title":"System call read()","text":""},{"location":"file_system/#include_3","title":"include  <p>int read (int fd, void *buf, size_t nbytes); \u2756 Read from file fd a number of bytes equal to nbytes, storing them in buf \u2756 Returned values \u27a2 number of read bytes on success \u27a2 -1 on error \u27a2 0 in the case of EOF</p>","text":""},{"location":"file_system/#system-call-read_1","title":"System call read()","text":""},{"location":"file_system/#include_4","title":"include  <p>int read (int fd, void *buf, size_t nbytes); \u2756 The returned value is lower that nbytes \u27a2 If the end of the file is reached before nbytes bytes have been read \u27a2 If the pipe you are reading from does not contain nbytes bytes</p>","text":""},{"location":"file_system/#system-call-write","title":"System call write()","text":""},{"location":"file_system/#include_5","title":"include  <p>int write (int fd, void *buf, size_t nbytes); \u2756 Write nbytes bytes from buf in the file identified by descriptor fd \u2756 Returned values \u27a2 The number of written bytes in the case of success, i.e., normally nbytes \u27a2 -1 on error</p>","text":""},{"location":"file_system/#system-call-write_1","title":"System call write()","text":""},{"location":"file_system/#include_6","title":"include  <p>int write (int fd, void *buf, size_t nbytes); \u2756 Remark \u27a2 write writes on the system buffer, not on the disk \u25aa fd = open (file, O_WRONLY | O_SYNC); \u27a2 O_SYNC forces the sync of the buffers, but only for ext2 file systems</p> <p>Examples: File R/W float data[10]; if ( write(fd, data, 10*sizeof(float))==(-1) ) { fprintf (stderr, \"Error: Write %d).\\n\", n); } } writing of the vector data (of float) struct { char name[L]; int n; float avg; } item; if ( write(fd,&amp;item,sizeof(item)))==(-1) ) { fprintf (stderr, \"Error: Write %d).\\n\", n); } } Writing of the serialized struct item (with 3 fields)</p>","text":""},{"location":"file_system/#system-call-lseek","title":"System call lseek()","text":""},{"location":"file_system/#include_7","title":"include  <p>off_t lseek (int fd, off_t offset, int whence); \u2756 The current position of the file offset is associated to each file \u27a2 The system call lseek assigns the value offset to the file offset \u27a2 The offset value is expressed in bytes</p>","text":""},{"location":"file_system/#system-call-lseek_1","title":"System call lseek()","text":""},{"location":"file_system/#include_8","title":"include  <p>off_t lseek (int fd, off_t offset, int whence); \u2756 whence specifies the interpretation of offset \u27a2 If whence==SEEK_SET \u25aa The offset is evaluated from the beginning of the file \u27a2 If whence==SEEK_CUR \u25aa The offset is evaluated from the current position \u27a2 If whence==SEEK_END \u25aa The offset is evaluated from the end of the file The value of offset can be positive or negative It is possible to leave \"holes\" in a file (filled with zeros)</p>","text":""},{"location":"file_system/#system-call-lseek_2","title":"System call lseek()","text":""},{"location":"file_system/#include_9","title":"include  <p>off_t lseek (int fd, off_t offset, int whence); \u2756 Returned values \u27a2 new offset on success \u27a2 -1 on error</p>","text":""},{"location":"file_system/#system-call-close","title":"System call close()","text":""},{"location":"file_system/#include_10","title":"include  <p>int close (int fd); \u2756 Returned values \u27a2 0 on success \u27a2 -1 on error \u2756 All the open files are closed automatically when the process terminates</p>","text":""},{"location":"file_system/#example-file-rw","title":"Example: File R/W","text":"<pre><code>#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#define BUFFSIZE 4096\nint main(void) {\n    int nR, nW, fdR, fdW;\n    char buf[BUFFSIZE];\n    fdR = open (argv[1], O_RDONLY);\n    fdW = open (argv[2], O_WRONLY | O_CREAT | O_TRUNC,\n    S_IRUSR | S_IWUSR);\n    if ( fdR==(-1) || fdW==(-1) ) {\n        fprintf (stdout, \u201cError Opening a File.\\n\u201c);\n    exit (1);\n}\n</code></pre>"},{"location":"file_system/#example-file-rw_1","title":"Example : File R/W","text":"<p>while ( (nR = read (fdR, buf, BUFFSIZE)) &gt; 0 ) { nW = write (fdW, buf, nR); if ( nR!=nW ) fprintf (stderr, \"Error: Read %d, Write %d).\\n\", nR, nW); } if ( nR &lt; 0 ) fprintf (stderr, \"Write Error.\\n\"); close (fdR); close (fdW); exit(0); } Error check on the last reading operation This program works indifferently on text and binary files</p>"},{"location":"file_system_refined/","title":"File system refined","text":""},{"location":"file_system_refined/#information-storage","title":"Information Storage","text":""},{"location":"file_system_refined/#overview","title":"Overview","text":"<p>Information storage allows data to be preserved across time, unaffected by various disruptions such as program termination, power loss, or system crashes. Files, as logical entities, encapsulate data in a structured format that is encoded for efficient storage and retrieval.</p>"},{"location":"file_system_refined/#logical-perspective-on-files","title":"Logical Perspective on Files","text":"<p>A file is a structured repository of related data, characterized by: 1. Content: Numbers, text, images, and other data types stored using standardized encoding systems. 2. Storage: Represented as a sequence of bytes within a contiguous address space on a storage medium.</p>"},{"location":"file_system_refined/#encoding-systems","title":"Encoding Systems","text":""},{"location":"file_system_refined/#ascii-american-standard-code-for-information-interchange","title":"ASCII (American Standard Code for Information Interchange)","text":"<ol> <li>Original ASCII:  </li> <li>Contains 128 characters.</li> <li>Includes 32 non-printable control characters and 96 printable symbols.</li> <li> <p>Encoded using 7 bits per character.</p> </li> <li> <p>Extended ASCII:  </p> </li> <li>Extends the standard to 8 bits, accommodating 255 characters.</li> <li>Variants include:<ul> <li>ISO 8859-1 (Latin-1): Western European languages.</li> <li>ISO 8859-5: Cyrillic alphabet.</li> <li>Others for Eastern European and additional languages.</li> </ul> </li> </ol>"},{"location":"file_system_refined/#unicode","title":"Unicode","text":"<ol> <li>Purpose: Industrial standard designed to represent characters from all writing systems.</li> <li>Key Features:</li> <li>Over 110,000 characters.</li> <li>Includes symbols and scripts across various languages.</li> <li>Implementations:</li> <li>UTF-8: Variable-length encoding (1-4 bytes).<ul> <li>Backward-compatible with ASCII for the first 128 characters.</li> </ul> </li> <li>UTF-16: Variable-length encoding (2-4 bytes).</li> <li>UTF-32: Fixed-length encoding (4 bytes).</li> </ol>"},{"location":"file_system_refined/#file-types","title":"File Types","text":"<ol> <li>Textual Files:  </li> <li>Encoded in ASCII or similar formats.</li> <li> <p>Line-oriented (e.g., newline characters for line breaks differ by OS).</p> <ul> <li>Unix/Linux: LF (<code>\\n</code>).</li> <li>Windows: CR+LF (<code>\\r\\n</code>).</li> </ul> </li> <li> <p>Binary Files:  </p> </li> <li>Store raw byte sequences, not limited to printable characters.</li> <li>Compact and efficient for numeric data or executables.</li> <li>Advantages:<ul> <li>Smaller size.</li> <li>Fixed structure simplifies file editing and navigation.</li> </ul> </li> <li>Drawbacks:<ul> <li>Limited portability.</li> <li>Cannot be directly edited using standard text editors.</li> </ul> </li> </ol>"},{"location":"file_system_refined/#serialization","title":"Serialization","text":"<p>Serialization converts complex data structures into storable or transmittable formats: 1. Encodes data as a sequential stream of bytes. 2. Enables reconstruction of the original structure during deserialization. 3. Supported in programming languages like Java, Python, and Ruby.</p>"},{"location":"file_system_refined/#file-io-in-c","title":"File I/O in C","text":""},{"location":"file_system_refined/#standard-library-functions","title":"Standard Library Functions","text":"<ol> <li>Open and Close:</li> <li><code>fopen()</code>: Opens a file.</li> <li> <p><code>fclose()</code>: Closes a file.</p> </li> <li> <p>Character-by-Character I/O:</p> </li> <li> <p><code>getc()</code>, <code>putc()</code>: Read/write single characters.</p> </li> <li> <p>Line-by-Line I/O:</p> </li> <li> <p><code>fgets()</code>, <code>fputs()</code>: Read/write entire lines.</p> </li> <li> <p>Formatted I/O:</p> </li> <li> <p><code>printf()</code>, <code>scanf()</code>: Process data in specified formats.</p> </li> <li> <p>Binary I/O:</p> </li> <li><code>fread()</code>, <code>fwrite()</code>: Operate on blocks of data.</li> </ol>"},{"location":"file_system_refined/#posix-system-calls","title":"POSIX System Calls","text":"<p>For low-level, unbuffered file access: - open(): Opens a file and returns a descriptor. - read(): Reads bytes from a file. - write(): Writes bytes to a file. - lseek(): Adjusts the file pointer. - close(): Closes the file descriptor.</p>"},{"location":"file_system_refined/#key-concepts-in-binary-io","title":"Key Concepts in Binary I/O","text":"<ol> <li>Binary files often store serialized data, enabling compact storage.</li> <li>Compatibility issues may arise due to varying architectures (e.g., byte order, field alignment).</li> </ol> <p>This structured explanation bridges technical details with conceptual clarity, covering the essential aspects of information storage and file management. Let me know if you'd like to expand on specific sections or require examples!</p>"},{"location":"pthreads/","title":"POSIX threads or Pthreads","text":"<p>A thread is a function that is executed in concurrency with the main thread A process with multiple threads = a set of independently executing functions that share the process resources</p> <p>The Pthreads library allows 1. Creating and manipulating threads 2. Synchronizing threads 3. Protection of resources shared by threads 4. Thread scheduling 5. Destroying thread</p> <p>It defines more than 60 functions 1. All functions have a <code>pthread_*</code> prefix 2. <code>pthread_equal</code>, <code>pthread_self</code>, <code>pthread_create</code>, <code>pthread_exit</code>, <code>pthread_join</code>, <code>pthread_cancel</code>, <code>pthread_detach</code></p> <p>The Pthread system calls are defined in 1. pthreads.h 2. It is necessary to remember 3. To insert in the .c files 4. <code>#include &lt;pthread.h&gt;</code> 5. Compile your program linking the pthread library 6. <code>gcc -Wall -g -o &lt;exeName&gt; &lt;file.c&gt; -lpthread</code></p> <p>A thread is uniquely identified 1. By a type identifier pthread_t 2. Similar to the PID of a process (pid_t) 3. The type pthread_t is opaque 4. Its definition is implementation dependent 5. Can be used only by functions specifically defined in Pthreads 6. It is not possible compare directly two identifiers or print their values 7. It has meaning only within the process where the thread is executed 8. Remember that the PID is global within the system</p>"},{"location":"theory_IOprimitives_1/","title":"I/O Primitives in C","text":""},{"location":"theory_IOprimitives_1/#accepting-cli-arguments","title":"Accepting CLI arguments:","text":"<pre><code>int main(int argc, char ** argv){\n    // in the code, to call them: argv[1], argv[2] ...\n    // argv[0] is the name of the executable itself, say, \"a.out\"\n    // so it goes: ./a.out argument1 argument2 ..\n}\n</code></pre>"},{"location":"theory_IOprimitives_1/#char-vectors","title":"Char vectors","text":"<p>1 char = 1 byte</p> <pre><code>char name[1024];\n</code></pre> <p>Strings in C end in a NULL element. So the maximum number that can be contained in a [1024] vector of char is 1023 char, plus the NULL element \"\\0\".</p> <p>[1024] is the contiguos number of char allocated on the stack.</p>"},{"location":"theory_IOprimitives_1/#buffers","title":"Buffer(s)","text":"<p>A buffer is a temporary storage space used to read files, to perform I/O operations or to manipulate data.</p>"},{"location":"theory_IOprimitives_1/#overview-on-the-io-primitives","title":"Overview on the I/O primitives","text":"<p>These are standard ANSI C I/O functions for file operations</p>"},{"location":"theory_IOprimitives_1/#comparison-of-their-uses","title":"Comparison of Their Uses","text":"Function Purpose Level of Operation fgetc Read a single character Character-based fputc Write a single character Character-based fscanf Read formatted data Formatted input fprintf Write formatted data Formatted output fgets Read a string/line Line or string-based fputs Write a string/line Line or string-based"},{"location":"theory_IOprimitives_1/#when-to-use-which","title":"When to Use Which","text":"<ul> <li><code>fgetc</code> and <code>fputc</code>:</li> <li> <p>Use when you need to process files character by character, such as counting    characters or detecting specific ones.</p> </li> <li> <p><code>fscanf</code> and <code>fprintf</code>:</p> </li> <li> <p>Use when working with structured data where formatting matters (e.g., reading    integers, floats, or a mix of types from a file).</p> </li> <li> <p><code>fgets</code> and <code>fputs</code>:</p> </li> <li>Use when working with text files line-by-line or dealing with strings.</li> </ul>"},{"location":"theory_IOprimitives_1/#sprintf","title":"<code>sprintf</code>","text":"<p>The function <code>sprintf</code> writes formatted (by you) data to a string, instead of standard output, like <code>printf</code> does.</p> <pre><code>char name[1024];\n\nsprintf(name, \"%s.1\", argv[2]);\n</code></pre> <p>say argv[2] is <code>test</code>, then it writes onto name the string: <code>test.1</code></p>"},{"location":"theory_IOprimitives_1/#reading-a-file-using-fscanf","title":"Reading a file using <code>fscanf</code>","text":"<pre><code>FILE *destination, *source;\nchar c;\n\nwhile(fscanf(source, \"%c\", &amp;c) != EOF){\n    fprintf(destination, \"%c\", c);\n}\n</code></pre>"},{"location":"theory_IOprimitives_2/","title":"I/O Primitives in C","text":""},{"location":"theory_IOprimitives_2/#fgetcfputc","title":"fgetc/fputc","text":"<p>The following is one whole program that reads char-by-char from a file and write said content onto another one</p> <pre><code>#include &lt;stdio.h&gt;\nint main (int argc, char **argv) { // This line allows me to execute this program on the prompt by accepting CL arguments\n  FILE *fs, *fd;\n  char c;\n  char name[1024];\n\n  // Solution using fgetc and fputc\n  sprintf (name, \"%s.2\", argv[2]);\n  fs = fopen(argv[1], \"r\");\n  fd = fopen(name, \"w\");\n  while ((c = fgetc(fs)) != EOF) {\n    fputc (c, fd);\n  }\n  fclose(fs);\n  fclose(fd);\n\n  return 0;\n}\n</code></pre> <p>This is the portion worth analizing</p> <pre><code>  fs = fopen(argv[1], \"r\");\n  fd = fopen(name, \"w\");\n  while ((c = fgetc(fs)) != EOF) {\n    fputc (c, fd);\n  }\n</code></pre> <ul> <li><code>c = fgetc(fs)</code>: reads the \"next\" char from the file \"fs\" and stores it into the <code>char c</code> variable</li> <li><code>(c = fgetc(fs)) != EOF</code>: the expression <code>(c = fgetc(fs))</code> is equivalent to a single char type variable, when it is not a EOF variable</li> <li><code>fputc(c, fd);</code>: writes the <code>char c</code> onto fd</li> </ul>"},{"location":"theory_IOprimitives_2/#fscanffprintf","title":"fscanf/fprintf","text":""},{"location":"theory_IOprimitives_2/#fgetsfputs","title":"fgets/fputs","text":""},{"location":"theory_IOprimitives_3/","title":"I/O Primitives in C","text":""},{"location":"theory_IOprimitives_3/#binary-io","title":"Binary I/O","text":""},{"location":"theory_IOprimitives_3/#fread","title":"<code>fread</code>","text":""},{"location":"theory_IOprimitives_3/#fwrite","title":"<code>fwrite</code>","text":""},{"location":"theory_IOprimitives_4/","title":"POSIX system calls for File Handling","text":"<p>The POSIX system calls <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close()</code> are low-level file operations used in C programming to interact with files. They provide direct interaction with the operating system and are included in <code>&lt;fcntl.h&gt;</code> and <code>&lt;unistd.h&gt;</code>. Below is an explanation of how to use each of these system calls, with examples.</p>"},{"location":"theory_IOprimitives_4/#1-open","title":"1. <code>open()</code>","text":"<p>The <code>open()</code> system call opens a file for reading, writing, or both. It returns a file descriptor (an integer) that is used in subsequent file operations.</p>"},{"location":"theory_IOprimitives_4/#syntax","title":"Syntax","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nint open(const char *pathname, int flags, mode_t mode);\n</code></pre> <ul> <li><code>pathname</code>: The file to open (e.g., <code>\"file.txt\"</code>).</li> <li><code>flags</code>: Specifies the access mode:</li> <li><code>O_RDONLY</code>: Open for reading.</li> <li><code>O_WRONLY</code>: Open for writing.</li> <li><code>O_RDWR</code>: Open for reading and writing.</li> <li>Add flags like <code>O_CREAT</code> (create file if it doesn\u2019t exist) or <code>O_APPEND</code> (append mode).</li> <li><code>mode</code>: File permissions (only used if creating a file, e.g., <code>0644</code> for <code>rw-r--r--</code>).</li> </ul>"},{"location":"theory_IOprimitives_4/#example","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    int fd = open(\"example.txt\", O_WRONLY | O_CREAT, 0644);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    // Use `fd` for further operations\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"theory_IOprimitives_4/#2-read","title":"2. <code>read()</code>","text":"<p>The <code>read()</code> system call reads data from a file into a buffer.</p>"},{"location":"theory_IOprimitives_4/#syntax_1","title":"Syntax","text":"<pre><code>ssize_t read(int fd, void *buf, size_t count);\n</code></pre> <ul> <li><code>fd</code>: File descriptor returned by <code>open()</code>.</li> <li><code>buf</code>: Buffer to store the data.</li> <li><code>count</code>: Number of bytes to read.</li> <li>Returns: Number of bytes actually read, or <code>0</code> if end-of-file (EOF) is reached.</li> </ul>"},{"location":"theory_IOprimitives_4/#example_1","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char buffer[128];\n    int fd = open(\"example.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1);\n    if (bytesRead == -1) {\n        perror(\"read\");\n        close(fd);\n        return 1;\n    }\n    buffer[bytesRead] = '\\0'; // Null-terminate the buffer\n    printf(\"Read: %s\\n\", buffer);\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"theory_IOprimitives_4/#3-write","title":"3. <code>write()</code>","text":"<p>The <code>write()</code> system call writes data from a buffer to a file.</p>"},{"location":"theory_IOprimitives_4/#syntax_2","title":"Syntax","text":"<pre><code>ssize_t write(int fd, const void *buf, size_t count);\n</code></pre> <ul> <li><code>fd</code>: File descriptor returned by <code>open()</code>.</li> <li><code>buf</code>: Buffer containing the data to write.</li> <li><code>count</code>: Number of bytes to write.</li> <li>Returns: Number of bytes written.</li> </ul>"},{"location":"theory_IOprimitives_4/#example_2","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    const char *text = \"Hello, world!\\n\";\n    int fd = open(\"example.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    ssize_t bytesWritten = write(fd, text, 14);\n    if (bytesWritten == -1) {\n        perror(\"write\");\n        close(fd);\n        return 1;\n    }\n    printf(\"Wrote %zd bytes\\n\", bytesWritten);\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"theory_IOprimitives_4/#4-close","title":"4. <code>close()</code>","text":"<p>The <code>close()</code> system call closes an open file descriptor, releasing the resources associated with it.</p>"},{"location":"theory_IOprimitives_4/#syntax_3","title":"Syntax","text":"<pre><code>int close(int fd);\n</code></pre> <ul> <li><code>fd</code>: File descriptor to close.</li> <li>Returns: <code>0</code> on success, or <code>-1</code> on failure.</li> </ul>"},{"location":"theory_IOprimitives_4/#example_3","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    int fd = open(\"example.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    // Perform file operations...\n    if (close(fd) == -1) {\n        perror(\"close\");\n        return 1;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"theory_IOprimitives_4/#complete-example-file-copy-program","title":"Complete Example: File Copy Program","text":"<p>Here's a small program that copies the content of one file to another:</p> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char buffer[1024];\n    ssize_t bytesRead, bytesWritten;\n\n    // Open source file\n    int source = open(\"source.txt\", O_RDONLY);\n    if (source == -1) {\n        perror(\"open source\");\n        return 1;\n    }\n\n    // Open destination file\n    int dest = open(\"dest.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (dest == -1) {\n        perror(\"open dest\");\n        close(source);\n        return 1;\n    }\n\n    // Read and write loop\n    while ((bytesRead = read(source, buffer, sizeof(buffer))) &gt; 0) {\n        bytesWritten = write(dest, buffer, bytesRead);\n        if (bytesWritten != bytesRead) {\n            perror(\"write\");\n            close(source);\n            close(dest);\n            return 1;\n        }\n    }\n    if (bytesRead == -1) {\n        perror(\"read\");\n    }\n\n    // Close files\n    close(source);\n    close(dest);\n    return 0;\n}\n</code></pre>"},{"location":"theory_IOprimitives_4/#notes","title":"Notes:","text":"<ul> <li>Always check the return values of these calls for errors.</li> <li>Errors can be inspected using <code>errno</code> and printed with <code>perror()</code> or <code>strerror()</code>.</li> <li>File permissions (e.g., <code>0644</code>) are written in octal.</li> </ul> <p>Let me know if you have further questions!</p>"}]}