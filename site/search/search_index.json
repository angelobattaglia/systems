{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkDocs Workflow","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"CompilationProcess/GCC/","title":"GCC","text":""},{"location":"CompilationProcess/GCC/#compilers","title":"Compilers","text":""},{"location":"CompilationProcess/GCC/#references","title":"References","text":"<ul> <li>Inlcude guard (wikipedia link)</li> <li>Systems Programming in UNIX Linux by K.C. Wang, Springer</li> <li>Driving Compilers</li> </ul>"},{"location":"CompilationProcess/GCC/#compiling-two-files-into-a-binary","title":"Compiling two files into a binary","text":"<p>Simply compiling two files into one executable</p> <pre><code>gcc Script01.c Script02.c\n</code></pre>"},{"location":"CompilationProcess/GCC/#the-c-flag","title":"The <code>-c</code> flag","text":"<p>When you compile a file using <code>gcc</code> with the <code>-c</code> flag, the process stops after the compilation phase and generates an object file (<code>Script02.o</code>) instead of a final executable. Here's what this means:</p>"},{"location":"CompilationProcess/GCC/#breaking-it-down","title":"Breaking it Down","text":"<ol> <li>Source Code (<code>Script02.c</code>): </li> <li> <p>The <code>.c</code> file is a text file containing the C source code.</p> </li> <li> <p>Compilation with <code>-c</code>: </p> </li> <li>The <code>gcc -c</code> command translates the source code into machine code, creating an object file (<code>Script02.o</code>).</li> <li> <p>It doesn\u2019t link the object file with other object files or libraries to create an executable at this stage.</p> </li> <li> <p>Object File (<code>Script02.o</code>): </p> </li> <li>This file contains the compiled machine code but is not standalone or executable. </li> <li>It needs to be linked with other object files and libraries in a later step to produce an executable.</li> </ol>"},{"location":"CompilationProcess/GCC/#why-use-c","title":"Why Use <code>-c</code>?","text":"<ul> <li>Modularity: In larger projects, code is split across multiple source files. Compiling each file individually into object files speeds up the process. If one file changes, you only need to recompile that file, not the entire project.</li> <li>Error Isolation: Errors can be found and fixed in each source file individually before moving to the linking phase.</li> <li>Separation of Compilation and Linking: It separates the code's transformation to machine instructions (compilation) from combining those instructions into a runnable program (linking).</li> </ul>"},{"location":"CompilationProcess/GCC/#example-usage","title":"Example Usage","text":"<pre><code>gcc -c Script02.c       # Compiles to Script02.o\ngcc -o program Script02.o   # Links to create 'program' (the executable)\n</code></pre>"},{"location":"CompilationProcess/GCC/#in-short","title":"In Short:","text":"<p>Using <code>gcc -c</code> means \"compile only\"\u2014you are generating intermediate object files for later use, not a complete program.</p>"},{"location":"CompilationProcess/GCC/#exporting-a-library-path","title":"Exporting a library path","text":"<p>Exporting a library path typically means setting an environment variable that tells the operating system or a program where to find shared libraries (or dynamic link libraries, depending on your system) when they are needed at runtime. This is especially common in Unix-like systems such as Linux and macOS.</p> <p>The library path refers to a directory or a set of directories where the system should look for shared libraries. By exporting this path, you make it available to processes that are spawned by the current shell session.</p>"},{"location":"CompilationProcess/GCC/#why-export-a-library-path","title":"Why export a library path?","text":"<ul> <li>To allow programs to locate and use shared libraries that are not installed in the system's default library directories (e.g., <code>/lib</code>, <code>/usr/lib</code>).</li> <li>To override system-wide library paths with custom ones, such as libraries installed in user-specific locations.</li> <li>To facilitate testing or development with specific versions of libraries.</li> </ul>"},{"location":"CompilationProcess/GCC/#how-is-it-done","title":"How is it done?","text":"<p>On Linux and Unix-like systems, the <code>LD_LIBRARY_PATH</code> environment variable is commonly used. You export it in a shell like this:</p> <pre><code>export LD_LIBRARY_PATH=/path/to/your/library:$LD_LIBRARY_PATH\n</code></pre> <ul> <li><code>/path/to/your/library</code>: The directory containing the libraries you want to use.</li> <li><code>$LD_LIBRARY_PATH</code>: Appends the new path to the existing library paths to preserve them.</li> </ul>"},{"location":"CompilationProcess/GCC/#example","title":"Example","text":"<p>Suppose you have a custom library in <code>/home/angelo/custom_lib</code>, and you want your program to use it. You would run:</p> <pre><code>export LD_LIBRARY_PATH=/home/angelo/custom_lib:$LD_LIBRARY_PATH\n</code></pre> <p>Now, when you run a program that requires this library, the system will search <code>/home/angelo/custom_lib</code> first.</p>"},{"location":"CompilationProcess/GCC/#for-windows","title":"For Windows","text":"<p>On Windows, library paths are typically managed by setting the <code>PATH</code> environment variable to include the directory of your <code>.dll</code> files.</p> <p>For example:</p> <pre><code>set PATH=C:\\path\\to\\your\\library;%PATH%\n</code></pre> <p>This ensures the operating system knows where to look for <code>.dll</code> files at runtime.</p>"},{"location":"CompilationProcess/GCC/#concepts-regarding-the-path-variables-for-executables-and-libraries","title":"Concepts regarding the PATH variables for executables and libraries","text":""},{"location":"CompilationProcess/GCC/#1-shell-configuration-files-bashrc-profile-etc","title":"1. Shell Configuration Files (<code>.bashrc</code>, <code>.profile</code>, etc.)","text":"<ul> <li>The shell (e.g., Bash, Zsh) is your interface to the operating system. Configuration files like <code>~/.bashrc</code> or <code>~/.profile</code> are used to customize the shell environment for your user.</li> <li>These files are not directly involved in compilation or execution but are used to set up environment variables (like <code>PATH</code> and <code>LD_LIBRARY_PATH</code>) that influence how the operating system and shell behave when you compile or run programs.</li> </ul>"},{"location":"CompilationProcess/GCC/#2-environment-variables-and-the-role-of-path-and-ld_library_path","title":"2. Environment Variables and the Role of <code>PATH</code> and <code>LD_LIBRARY_PATH</code>","text":"<p>When you modify these variables in <code>~/.bashrc</code> or <code>~/.profile</code>, you\u2019re instructing the shell to configure paths that the operating system uses:</p>"},{"location":"CompilationProcess/GCC/#path-for-executables","title":"<code>PATH</code> for Executables","text":"<ul> <li>When you run a command (e.g., <code>gcc</code>, <code>python</code>), the shell searches the directories listed in the <code>PATH</code> environment variable to locate the executable.</li> <li>Example:   <code>bash   export PATH=/usr/local/cuda/bin:$PATH</code></li> <li>This tells the shell to include <code>/usr/local/cuda/bin</code> (where CUDA executables like <code>nvcc</code> are stored) in the list of directories it checks when you run a command.</li> </ul>"},{"location":"CompilationProcess/GCC/#ld_library_path-for-libraries","title":"<code>LD_LIBRARY_PATH</code> for Libraries","text":"<ul> <li>When a program is executed, it might rely on shared libraries (like <code>.so</code> files). The operating system uses <code>LD_LIBRARY_PATH</code> to find these libraries at runtime.</li> <li>Example:   <code>bash   export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</code></li> <li>This tells the operating system to include <code>/usr/local/cuda/lib64</code> (where CUDA libraries like <code>libcudart.so</code> are stored) when searching for shared libraries.</li> </ul>"},{"location":"CompilationProcess/GCC/#3-compilation-and-execution-in-unix-systems","title":"3. Compilation and Execution in Unix Systems","text":"<ul> <li>Compiling: When you compile a program (e.g., with <code>gcc</code>), the compiler looks for:</li> <li>Executables (e.g., <code>gcc</code>, <code>nvcc</code>): Found via the <code>PATH</code>.</li> <li>Header files (<code>.h</code>): Searched in directories specified by <code>-I</code> or defaults like <code>/usr/include</code>.</li> <li>Libraries (<code>.so</code>, <code>.a</code>): Searched in directories specified by <code>-L</code> or defaults like <code>/usr/lib</code>.</li> </ul> <p>If you set <code>PATH</code>, the shell can find compilers like <code>nvcc</code>. Similarly, if you pass flags like <code>-I</code> and <code>-L</code>, the compiler knows where to find headers and libraries.</p> <ul> <li>Execution: Once compiled, executables may rely on shared libraries. If the required libraries are not in standard paths, <code>LD_LIBRARY_PATH</code> must be set to help the operating system locate them.</li> </ul>"},{"location":"CompilationProcess/GCC/#4-the-role-of-bashrc-and-profile","title":"**4. The Role of <code>.bashrc</code> and <code>.profile</code>","text":"<ul> <li>Files like <code>.bashrc</code> and <code>.profile</code> are only scripts that run when you start a shell session. They allow you to automatically configure your environment.</li> <li>For example, if you add the following to <code>~/.bashrc</code>:   <code>bash   export PATH=/usr/local/cuda/bin:$PATH   export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</code></li> <li>Every new shell session will automatically have these variables set.</li> <li>This ensures commands like <code>nvcc</code> work and the necessary CUDA libraries are found at runtime.</li> </ul>"},{"location":"CompilationProcess/GCC/#5-summary-of-what-happens","title":"5. Summary of What Happens","text":"<ol> <li>At shell startup: Files like <code>~/.bashrc</code> are sourced, setting environment variables.</li> <li>When you run a command:</li> <li>The shell uses <code>PATH</code> to locate the executable.</li> <li>When the program executes:</li> <li>The operating system uses <code>LD_LIBRARY_PATH</code> to locate required shared libraries.</li> </ol> <p>The <code>.bashrc</code> or <code>.profile</code> files themselves are not magic; they simply automate the process of setting environment variables for the shell and, indirectly, the operating system.</p>"},{"location":"CompilationProcess/dynamiclinking/","title":"Dynamic Linking","text":"<ul> <li>First step: compile Script02.c into Script02.o, -fPIC compile to Position Independent Code Script02.o</li> </ul> <pre><code>gcc -c -fPIC Script02.c\n</code></pre> <ul> <li>Second step: create a shared (-shared) Dinamically Linked Library (.so) with Script02.o as a member of it</li> </ul> <pre><code>gcc -shared -o libmylib.so Script02.o\n</code></pre> <ul> <li>Third step: Static compile-link Script01.c with libmylib.a as a linked library</li> <li>'-L.' specifies the library path (current directory . or you can specify it)</li> <li>'-l' specifies the library as seen next</li> <li>'-lmylib' is specified without the prefex lib, as well as the suffix .a</li> </ul> <pre><code>gcc Script01.c -L. -lmylib\n</code></pre> <p>After installation, you need to add the CUDA binaries to your system's PATH and library paths. You can do this by adding the following lines to your <code>~/.bashrc</code> or <code>~/.profile</code> file:</p> <pre><code># Add CUDA to PATH\nexport PATH=/usr/local/cuda/bin:$PATH\n# Add CUDA libraries to LD_LIBRARY_PATH\nexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH\n</code></pre> <p>After adding these lines, reload your shell configuration:</p> <pre><code>source ~/.bashrc\n</code></pre> <ul> <li>Third-2 step: exporting the LD_LIBRARY = ./</li> <li>If the library is not in the curent directory set LD_LIBRARY_PATH to point to the directory containing the library</li> </ul> <pre><code>export LD_LIBRARY_PATH = ./\n</code></pre> <ul> <li>Fourth step: run the result, i.e. a.out, as usual</li> </ul> <pre><code>./a.out\n</code></pre>"},{"location":"CompilationProcess/dynamiclinking/#dynamic-linking_1","title":"Dynamic Linking","text":"<ul> <li>Dynamic Linking is more efficient in terms of disk space and memory, and it offers flexibility with library updates, but it introduces dependencies on external libraries and potential compatibility issues.  This is a high-level overview, and there are more nuances, especially when you get into topics like dynamically loaded libraries (using <code>dlopen</code> and <code>dlsym</code> in C/C++), which allow for even more dynamic behavior.</li> </ul> <p>Dynamic linking involves keeping the code of libraries separate from the executable.  The linking happens at runtime, where the executable file contains references to the library functions it uses.</p> <ol> <li>How it Works:</li> <li>Dynamic libraries in Linux are typically <code>.so</code> (shared object) files.</li> <li>When you compile your program, the compiler leaves placeholders for the addresses of the functions from the library.</li> <li> <p>At runtime, the Linux loader (<code>ld.so</code>) fills in these placeholders with actual addresses of the library functions, which are loaded into memory.</p> </li> <li> <p>Advantages:</p> </li> <li>Reduced Size: Executables are smaller as they don't contain the actual library code.</li> <li>Shared Libraries: Multiple programs can share the same library code in memory, reducing overall memory usage.</li> <li> <p>Easy Updates: Updating a library does not require recompiling the programs using it.</p> </li> <li> <p>Disadvantages:</p> </li> <li>Dependency: Executables depend on external libraries being present on the system.</li> <li>Compatibility: Issues can arise if the wrong version of a library is used at runtime.</li> <li>Startup Time: Slightly longer startup times for programs as linking is done at runtime.</li> </ol>"},{"location":"CompilationProcess/dynamiclinking/#2-library-dependencies","title":"2. Library Dependencies","text":"<p>When you compile a binary, it often relies on shared libraries (dynamic libraries) that need to be present on the system for it to run. If these libraries are not found in the expected locations, the binary will fail to execute.</p> <ul> <li> <p>Checking Dependencies with <code>ldd</code>:   The <code>ldd</code> command prints the shared libraries required by a binary. For example:   <code>sh   ldd /usr/bin/your_binary</code>   This command will output something like:   <code>linux-vdso.so.1 (0x00007ffd5ed9e000)   libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fbd5e144000)   libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbd5dd7b000)   /lib64/ld-linux-x86-64.so.2 (0x00007fbd5e443000)</code>   If any libraries are marked as \"not found,\" you need to install those libraries or make sure they are in the correct path.</p> </li> <li> <p>Setting the Library Path:   If the libraries are installed in non-standard locations, you can set the <code>LD_LIBRARY_PATH</code> environment variable to include the paths where the libraries are located:   <code>sh   export LD_LIBRARY_PATH=/path/to/custom/libs:$LD_LIBRARY_PATH</code>   You can add this line to your <code>.bashrc</code> or <code>.profile</code> to make it persistent.</p> </li> <li> <p>Using <code>ldconfig</code>:   You can add the library path to <code>/etc/ld.so.conf</code> and run <code>ldconfig</code> to update the linker cache:   <code>sh   echo \"/path/to/custom/libs\" | sudo tee -a /etc/ld.so.conf   sudo ldconfig</code></p> </li> </ul>"},{"location":"CompilationProcess/dynamiclinking/#5-environment-variables","title":"5. Environment Variables","text":"<p>Environment variables can significantly affect how a binary runs. These variables provide configuration and setup information that the binary might depend on.</p> <ul> <li> <p>Common Environment Variables:   Some binaries might rely on variables like <code>PATH</code>, <code>LD_LIBRARY_PATH</code>, <code>PYTHONPATH</code>, <code>JAVA_HOME</code>, etc. Make sure these are set correctly:   <code>sh   export PATH=/usr/bin:$PATH   export LD_LIBRARY_PATH=/usr/lib:$LD_LIBRARY_PATH</code></p> </li> <li> <p>Checking and Setting Variables:   You can check the current value of an environment variable using <code>echo</code>:   <code>sh   echo $VARIABLE_NAME</code>   To set an environment variable for the current session:   <code>sh   export VARIABLE_NAME=value</code></p> </li> <li> <p>Persistent Settings:   To make these changes persistent, add them to your shell\u2019s configuration file (e.g., <code>.bashrc</code>, <code>.bash_profile</code>, or <code>.profile</code>):   <code>sh   echo 'export VARIABLE_NAME=value' &gt;&gt; ~/.bashrc   source ~/.bashrc</code></p> </li> </ul>"},{"location":"CompilationProcess/dynamiclinking/#6-file-system-differences","title":"6. File System Differences","text":"<p>Moving files between different file systems or partitions can sometimes cause issues, although this is less common with modern systems. Here are some considerations:</p> <ul> <li> <p>File System Types:   Different file systems (e.g., ext4, NTFS, FAT32) have different capabilities and restrictions. For instance, file permissions and ownership might not be preserved when moving files between file systems with different permission models.</p> </li> <li> <p>Mount Options:   The options used when mounting a file system can affect file execution. For example, the <code>noexec</code> option prevents execution of binaries on the mounted file system:   <code>sh   mount | grep /usr/bin</code>   Ensure that <code>/usr/bin</code> is not mounted with <code>noexec</code>.</p> </li> <li> <p>Inodes and File Metadata:   Some file systems handle file metadata differently. If the binary relies on specific metadata that\u2019s not preserved during the move, it might not run correctly. This is rare but can happen in specialized use cases.</p> </li> <li> <p>Consistency and Corruption:   Ensure the file system is consistent and not corrupted. Use tools like <code>fsck</code> to check and repair file system issues:   <code>sh   sudo fsck -f /dev/sdXn  # Replace /dev/sdXn with your actual device identifier</code></p> </li> </ul> <p>By examining these factors\u2014library dependencies, environment variables, and file system differences\u2014you can identify and resolve issues that prevent your binary from executing correctly after being moved.</p>"},{"location":"CompilationProcess/staticlinking/","title":"Static Linking","text":"<ul> <li>First step: compile Script02.c into Script02.o, important using the '-c' flag</li> </ul> <pre><code>gcc -c Script02.c\n</code></pre> <pre><code>gcc -c Script02.c       # Compiles to Script02.o\ngcc -o program Script02.o   # Links to create 'program' (the executable)\n</code></pre> <ul> <li>Second step: create a Statically Linked Library with Script02.o being a part of</li> </ul> <pre><code>ar rcs libmylib.a Script02.o\n</code></pre> <ul> <li>Third step: Static compile-link Script01.c with libmylib.a as a linked library</li> <li>'-static' specifies that is being statically linked</li> <li>'-L.' specifies the library path (current directory .)</li> <li>'-l' specifies the library</li> <li>'mylib' is specified without the prefex lib, as well as the suffix .a</li> </ul> <pre><code>gcc -static Script01.c -L. -lmylib\n</code></pre> <ul> <li>Fourth step: run the result, i.e. a.out, as usual</li> </ul> <pre><code>./a.out\n</code></pre>"},{"location":"CompilationProcess/staticlinking/#static-linking_1","title":"Static Linking","text":"<p>In the context of Linux and C/C++ programming, static and dynamic linking are two different methods of combining various pieces of code into a single executable program. Linking a C++ script with a library during the compilation process through the Command Line Interface (CLI) may vary depending on your operating system and development environment. In static linking, all the required code from external libraries and the application code are combined into a single large executable file during the compile time.  This includes copying the object code of used library functions directly into the final executable. When you compile your C/C++ program, the compiler links the object code of your program with the object code of any libraries you used. These libraries are typically <code>.a</code> (archive) files on Linux.  The end result is a standalone executable that contains all the necessary code, including the library functions. The advantages are that the final executable does not depend on external libraries at runtime and that you're ensured that the library version your program was compiled with is the one it runs with. It's also easier for the distribution as the executable is self-contained. The disadvantages concern the size, since the executables can be larger since they include all library code, and updating a library which results in recompiling all dependent programs. Also the resource usage, as multiple programs using the same library each have their own copy in memory, which can be optimized by just using one copy for them all.</p>"},{"location":"CompilationProcess/staticlinking/#steps","title":"Steps:","text":"<ol> <li>Write Your C++ Code:    Create your C++ source code file, for example, <code>main.cpp</code>.</li> </ol> <p>```cpp    // main.cpp    #include     #include \"mylibrary.h\" <p>int main() {        // Your code here        return 0;    }    ```</p> <ol> <li>Write the Library Code:    Create the library source code file, for example, <code>mylibrary.cpp</code>.</li> </ol> <p>```cpp    // mylibrary.cpp    #include  <p>void myLibraryFunction() {        // Your library code here    }    ```</p> <p>Create the corresponding header file, for example, <code>mylibrary.h</code>.</p> <p>```cpp    // mylibrary.h    #ifndef MYLIBRARY_H    #define MYLIBRARY_H</p> <p>void myLibraryFunction();</p> <p>#endif // MYLIBRARY_H    ```</p> <ol> <li>Compile Library:    Compile the library source code into a shared or static library. The exact command may vary based on your compiler and platform.</li> </ol> <p><code>bash    g++ -c mylibrary.cpp -o mylibrary.o    g++ -shared -o libmylibrary.so mylibrary.o  # For shared library (.so) on Linux</code></p> <p>Or for a static library:</p> <p><code>bash    ar rcs libmylibrary.a mylibrary.o  # For static library (.a)</code></p> <ol> <li>Compile Main Code:    Compile your main C++ code, linking it with the library. You'll need to specify the library file and its path.</li> </ol> <p><code>bash    g++ -o myprogram main.cpp -L/path/to/library -lmylibrary</code></p> <p>Replace <code>/path/to/library</code> with the actual path where your library file (<code>libmylibrary.so</code> or <code>libmylibrary.a</code>) is located.</p> <ol> <li>Run the Executable:    Run your compiled executable.</li> </ol> <p><code>bash    ./myprogram</code></p>"},{"location":"CompilationProcess/staticlinking/#notes","title":"Notes:","text":"<ul> <li>The specific commands and flags may vary depending on your compiler (e.g., <code>g++</code> for GCC, <code>clang++</code> for Clang) and operating system.</li> <li>Ensure that the library file and its path are correctly specified during the compilation process.</li> <li>Adjust library names and file extensions based on your platform (e.g., <code>.so</code> for shared libraries on Linux, <code>.dylib</code> for macOS, <code>.dll</code> for Windows).</li> <li>If using header files (<code>mylibrary.h</code>), make sure they are in the correct location or include the appropriate <code>-I</code> flag to specify the include path.</li> </ul> <p>Adapt the commands based on your specific requirements and development environment.</p>"},{"location":"CompilationProcess/staticlinking/#creating-and-packaging-a-statically-linked-library","title":"Creating and packaging a statically linked library","text":"<p>Creating and packaging a static library on Linux using GCC involves several steps. I'll guide you through the process with a simple example.</p> <p>Let's assume you have a library with two source files: <code>mylibrary.cpp</code> and <code>mylibrary.h</code>. We'll create a static library named <code>libmylibrary.a</code>.</p>"},{"location":"CompilationProcess/staticlinking/#1-write-library-code","title":"1. Write Library Code:","text":"<p>Create <code>mylibrary.h</code>:</p> <pre><code>// mylibrary.h\n#ifndef MYLIBRARY_H\n#define MYLIBRARY_H\n\nvoid myLibraryFunction();\n\n#endif // MYLIBRARY_H\n</code></pre> <p>Create <code>mylibrary.cpp</code>:</p> <pre><code>// mylibrary.cpp\n#include \"mylibrary.h\"\n#include &lt;iostream&gt;\n\nvoid myLibraryFunction() {\n    std::cout &lt;&lt; \"Hello from myLibraryFunction!\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"CompilationProcess/staticlinking/#2-compile-library","title":"2. Compile Library:","text":"<p>Compile the library source code into an object file and then create the static library.</p> <pre><code># Compile the source file into an object file\ng++ -c mylibrary.cpp -o mylibrary.o\n\n# Create the static library\nar rcs libmylibrary.a mylibrary.o\n</code></pre> <p>This will generate a static library file named <code>libmylibrary.a</code>.</p>"},{"location":"CompilationProcess/staticlinking/#3-write-main-code","title":"3. Write Main Code:","text":"<p>Create a main program, e.g., <code>main.cpp</code>:</p> <pre><code>// main.cpp\n#include \"mylibrary.h\"\n\nint main() {\n    myLibraryFunction();\n    return 0;\n}\n</code></pre>"},{"location":"CompilationProcess/staticlinking/#4-compile-main-code-with-the-library","title":"4. Compile Main Code with the Library:","text":"<p>Compile the main program, linking it with the static library.</p> <pre><code>g++ -o myprogram main.cpp -L. -lmylibrary\n</code></pre> <p>Here, <code>-L.</code> specifies the library search path (current directory), and <code>-lmylibrary</code> links against the <code>libmylibrary.a</code> static library.</p>"},{"location":"CompilationProcess/staticlinking/#5-run-the-executable","title":"5. Run the Executable:","text":"<p>Run your compiled executable:</p> <pre><code>./myprogram\n</code></pre> <p>This should print \"Hello from myLibraryFunction!\" to the console.</p>"},{"location":"CompilationProcess/staticlinking/#notes_1","title":"Notes:","text":"<ul> <li>Ensure that the library file (<code>libmylibrary.a</code>) is in the same directory or provide the correct path during the compilation.</li> <li>Adjust the compilation commands based on your specific project structure and requirements.</li> <li>The library file extension for static libraries is typically <code>.a</code> on Linux.</li> <li>You can distribute the <code>libmylibrary.a</code> file along with the header file (<code>mylibrary.h</code>) for others to use in their programs. They would then link against your static library when compiling their programs.</li> </ul>"},{"location":"CompilationProcess/staticlinking/#conclusion","title":"Conclusion","text":"<ul> <li>Static Linking is used when you want to ensure your program is self-contained and consistent, but at the cost of larger executable size and potentially more memory usage.</li> </ul>"},{"location":"CompilationProcess/Make/Make/","title":"Make","text":"<p>The mechanics of programming usually follow a fairly simple routine of editing source files, compiling the source into an executable form, and debugging the result. The make program is intended to automate the mundane aspects of transforming source code into an executable. The advantages of make over scripts is that you can specify the relationships between the elements of your program to make, and it knows through these relationships and timestamps exactly what steps need to be redone to produce the desired program each time. Using this information, make can also optimize the build process avoiding unnecessary steps.  O'Reilly Managing Projects with GNU Make, Third Edition By Robert Mecklenburg November 2004</p>"},{"location":"CompilationProcess/Make/Make/#install-cmake-if-you-need-it","title":"Install <code>cmake</code> if you need it","text":"<p>If you need <code>cmake</code> just install it</p> <pre><code>Install CMake using pip3 and link it for system-wide access:\n\npip3 install cmake==3.31.6\nsudo ln -sf /usr/local/bin/cmake /usr/bin/cmake\ncmake --version\n</code></pre>"},{"location":"CompilationProcess/Make/Make/#what-is-phony-and-how-to-use-it","title":"What is <code>.PHONY</code> and how to use it","text":"<p><code>.PHONY</code> tells <code>make</code>:</p> <p>\"This target is not a real file. It's just a name for a command I want to run.\"</p>"},{"location":"CompilationProcess/Make/Make/#why-use-it","title":"Why use it?","text":"<p>https://www.skenz.it/cs/makefile_1 Target listed after the keyword \u201c.PHONY\u201d are executed regardless the existence of a file with the same name that has been edited more recently than the dependencies.</p> <p>Imagine you have this in your Makefile:</p> <pre><code>clean:\n    rm -f *.o prog\n</code></pre> <p>If a file named <code>clean</code> exists in your folder, <code>make</code> will say:</p> <p>\"clean already exists \u2014 nothing to do.\"</p> <p>\ud83d\ude2c The command won't run!</p>"},{"location":"CompilationProcess/Make/Make/#how-to-fix-it","title":"How to fix it:","text":"<pre><code>.PHONY: clean\n\nclean:\n    rm -f *.o prog\n</code></pre> <p>Now, even if a file called <code>clean</code> exists, <code>make clean</code> will still run.</p>"},{"location":"CompilationProcess/Make/Make/#summary","title":"Summary","text":"<ul> <li><code>.PHONY</code> is for targets that are not files.</li> <li>It forces make to always run them.</li> <li>Common examples: <code>clean</code>, <code>all</code>, <code>install</code>, <code>test</code>.</li> </ul> <p>Make doesn\u2019t know whether a target is a command or a file \u2014 it assumes every target might be a file.</p>"},{"location":"CompilationProcess/Make/Make/#why-does-this-happen","title":"\ud83e\udde0 Why does this happen?","text":"<p><code>make</code> was designed to build files. That\u2019s its original purpose. So by default:</p> <ul> <li>If you write:</li> </ul> <p><code>make   clean:     rm -f *.o</code></p> <p><code>make</code> assumes <code>clean</code> might be a file you're trying to create. * If a file named <code>clean</code> exists in your directory, <code>make</code> will say:</p> <p>\"<code>clean</code> is up-to-date \u2014 skip the recipe.\"</p> <p>So <code>make</code> skips the command entirely, thinking the \"target\" (<code>clean</code>) is already \"built\".</p>"},{"location":"CompilationProcess/Make/Make/#why-phony-exists","title":"\ud83d\udee0 Why <code>.PHONY</code> exists","text":"<p><code>.PHONY</code> tells make:</p> <p>\"Hey, don\u2019t treat this as a file \u2014 this is a fake target. Always run it.\"</p> <p>That\u2019s why you do this:</p> <pre><code>.PHONY: clean\nclean:\n    rm -f *.o prog\n</code></pre> <p>Now, <code>make</code> won\u2019t care if there\u2019s a file called <code>clean</code> \u2014 it will always run the <code>clean:</code> recipe.</p>"},{"location":"CompilationProcess/Make/Make/#summary_1","title":"\u2699\ufe0f Summary","text":"Without <code>.PHONY</code> With <code>.PHONY</code> <code>make</code> checks if target exists as a file <code>make</code> skips file checks Might skip your recipe Always runs your recipe Confusing when debugging Predictable and safe"},{"location":"CompilationProcess/Make/Make/#big-idea","title":"\ud83e\udde9 Big idea:","text":"<p><code>make</code> is a file generator by design. If you're using it for commands (like <code>clean</code>), you must tell it explicitly.</p> <p>Here's a quick cheat sheet of common <code>.PHONY</code> targets used in Makefiles:</p>"},{"location":"CompilationProcess/Make/Make/#common-phony-targets","title":"\u2705 Common <code>.PHONY</code> Targets","text":"Target Purpose <code>all</code> Build everything (often the default target) <code>clean</code> Delete all compiled files and output (e.g. <code>*.o</code>, <code>prog</code>) <code>distclean</code> Like <code>clean</code>, but also remove generated directories/files <code>install</code> Copy the final program or files into a system location <code>uninstall</code> Remove files that were installed <code>test</code> Run tests <code>check</code> Alternative to <code>test</code>; runs validations <code>run</code> Run the program after building <code>rebuild</code> Clean and rebuild everything <code>help</code> Print help or usage info about available targets"},{"location":"CompilationProcess/Make/Make/#example","title":"\ud83e\uddfe Example","text":"<pre><code>.PHONY: all clean install run\n\nall: myprogram\n\nmyprogram: main.o\n    g++ -o myprogram main.o\n\nclean:\n    rm -f *.o myprogram\n\ninstall:\n    cp myprogram /usr/local/bin\n\nrun: myprogram\n    ./myprogram\n</code></pre> <p>With <code>.PHONY</code>, <code>make</code> will run these even if files named <code>clean</code>, <code>install</code>, or <code>run</code> exist.</p> <p>Would you like this as a downloadable PDF cheat sheet too?</p>"},{"location":"CompilationProcess/Make/MakeLatex/","title":"Compilation","text":""},{"location":"CompilationProcess/Make/MakeLatex/#the-best-latex-writing-system-imho","title":"The best Latex writing system (IMHO)","text":"<p>Creating a modular LaTeX document and building it with a Makefile is the best way to streamline the document creation process and enhance maintainability, in my opinion.  This approach is particularly useful for large documents, such as academic papers, theses, or books, where different sections or chapters can be worked on independently. It's also useful to provide a document that is reproducible from source, especially when letting the community on git-based websites the opportunity to contribute to it.</p>"},{"location":"CompilationProcess/Make/MakeLatex/#1-structuring-a-modular-latex-document","title":"1. Structuring a Modular LaTeX Document","text":"<p>A modular LaTeX document is one where different components of the document (e.g., chapters, sections, or custom commands) are contained in separate files.  This makes the document easier to manage, especially for collaborative projects. Here\u2019s how you might structure it:</p> <ul> <li>Main File: The main LaTeX file that includes the document class, preamble (with packages, custom commands, etc.), and input commands to include other files.</li> <li>Section Files: Separate <code>.tex</code> files for different sections or chapters of the document.</li> <li>Resources: Other directories may include figures, tables, or additional resources.</li> </ul> <p>An example structure could look like this:</p> <pre><code>main.tex\nsections/\n  - introduction.tex\n  - chapter1.tex\n  - chapter2.tex\n  - conclusion.tex\nfigures/\n  - figure1.png\n  - figure2.png\nMakefile\n</code></pre> <p>In <code>main.tex</code>, you would use <code>\\input{sections/introduction}</code> to include the <code>introduction.tex</code> file, and so on for the other sections. This approach keeps your main file clean and focuses only on the document structure.</p>"},{"location":"CompilationProcess/Make/MakeLatex/#2-writing-a-makefile-for-latex","title":"2. Writing a Makefile for LaTeX","text":"<p>A Makefile automates the compilation of your LaTeX document, handling the build process with simple commands. LaTeX documents often need multiple compilation passes to correctly generate tables of contents, lists of figures, and to resolve cross-references.</p> <p>Here's a simple Makefile template for a LaTeX project:</p> <pre><code># Makefile for compiling LaTeX documents\n\n# Name of the main LaTeX file without the extension\nMAIN = main\n\n# Default target\nall: pdf\n\n# Compile PDF\npdf:\n    pdflatex $(MAIN)\n    bibtex $(MAIN) || true # Run bibtex, ignore errors if no bibliography\n    pdflatex $(MAIN)\n    pdflatex $(MAIN)\n\n# Clean auxiliary files\nclean:\n    rm -f *.aux *.bbl *.blg *.log *.toc *.out\n\n# Clean all generated files\ndistclean: clean\n    rm -f $(MAIN).pdf\n</code></pre> <p>This Makefile defines several targets:</p> <ul> <li><code>all</code>: The default target, which just redirects to the <code>pdf</code> target.</li> <li><code>pdf</code>: Compiles the LaTeX document into a PDF, running <code>pdflatex</code> and <code>bibtex</code> as needed. It runs <code>pdflatex</code> multiple times to ensure all references are updated.</li> <li><code>clean</code>: Removes auxiliary files generated by LaTeX.</li> <li><code>distclean</code>: Removes all generated files, including the final PDF.</li> </ul> <p>To use this Makefile, you would run:</p> <ul> <li><code>make</code> or <code>make all</code> to compile the document into a PDF.</li> <li><code>make clean</code> to remove auxiliary files.</li> <li><code>make distclean</code> to remove all generated files, including the PDF.</li> </ul> <p>This setup allows for a clean and efficient workflow for managing and compiling modular LaTeX documents, particularly suitable for complex or large-scale projects.</p>"},{"location":"FileSystem/directories/","title":"Directories","text":"<p>No storage system contains a single file. - Files are organized in directories. A directory is a collection of files. - A directory is a node (of a tree) or a vertex of a graph that stores information about the file contained there - Both directories and files are saved in mass memory</p>"},{"location":"FileSystem/directories/#kpi-key-performance-indicators","title":"KPI (Key performance indicators)","text":"<ol> <li>Efficiency: speed in modifying the file system, i.e. deleting a file, searching a file .. </li> <li>Naming: how simple it is for a user to identify a file, and if the FS allows the assignment of the same name to different files</li> <li>Grouping: grouping the files based on the content they contain from a semantic point of view. (editors, compilers, documents ..)</li> </ol> <p>/ -&gt; summerpics/ -&gt; parent_pics/</p>"},{"location":"FileSystem/directories/#directories-with-only-one-level-no-subdirectories-allowed","title":"Directories with only one level (no subdirectories allowed)","text":"<p>cat/ bo/ a/ test/  ..</p>"},{"location":"FileSystem/directories/#definition-of-a-directory","title":"Definition of a Directory","text":"<p>A Directory is a list of files and pointers to the data. key, pointer to the data block that represents the file cat/, pointer to the file contained in cat/ bo/, poitner to the file contained in bo/ ..</p> <p>Key, Value filename, inode (is an integer) file.txt - 10257</p>"},{"location":"FileSystem/directories/#directories-with-two-levels","title":"Directories with two levels","text":""},{"location":"FileSystem/directories/#directories-with-three-levels","title":"Directories with three levels","text":""},{"location":"FileSystem/directories/#acyclic-graph-directories","title":"Acyclic graph directories","text":"<p>In linux you cannot have hard links to directories.</p>"},{"location":"FileSystem/directories/#contiguous-allocation","title":"Contiguous Allocation","text":"<p>The file system divides the hard disk in blocks of different dimensions. We create a partition and then we install a file system. In linux we have ext 4. If I have 11 kbs of a file, in blocks of 4 kbs, there's a phenomenon called internal segmentation.</p> <p>slide 23</p> <p>internal fragmentation: last block only partially used</p> <p>external fragmentaton: problem, can be solved with defragmentation. It's not good though, then if you want to appen something to a file that had other free memory ahead.  </p> <p>first fit, worst fit, best fit: question in the exam</p>"},{"location":"FileSystem/file_system/","title":"File system","text":"<p>Information Storage</p> <p>Information is preserved over extended periods, remaining unaffected by: 1. Program or process termination. 2. Loss of power supply or other disruptions. 3. Logical Perspective on Files</p> <p>A file is:   1. A structured collection of related data, encompassing elements such as numbers, text, images, and more.   2. Data stored on electronic devices using standardized encoding systems.   3. Represented in a contiguous address space within the storage medium.</p> <p>ASCII encoding De-facto standard \u27a2 ASCII, American Standard Code for Information Interchange 128 total characters 32 not printable 96 printable \u25aa Originally based on the English alphabet \u25aa 128 characters are coded in 7-bit (binary numbers) \u27a2 Extended ASCII (or high ASCII) \u25aa Extension of ASCII to 8-bit and 255 characters \u25aa Several versions exist \u25cf ISO 8859-1 (ISO Latin-1), ISO 8859-2 (Eastern European languages), ISO 8859-5 for Cyrillic languages, etc.</p> <p>Unicode encoding \u2756 Industrial standard that includes the alphabets for any existing writing system \u27a2 It contains more 110,000 characters \u27a2 It includes more than 100 sets of symbols \u2756 Several implementations exist \u27a2 UCS (Universal Character Set) \u27a2 UTF (Unicode Tranformation Format) \u25aa UTF-8, groups of 8 bits size (1, 2, 3 or 4 groups) \u25cf ASCII coded in the first 8 bits \u25aa UTF-16, groups of 16 bits size (1 or 2 groups) \u25aa UTF-32, groups of 32 bits size (fixed length)</p>"},{"location":"FileSystem/file_system/#textual-and-binary-files","title":"Textual and binary files","text":"<p>A file is basically a sequence of bytes written one after the other. Each byte includes 8 bits, with possible values 0 or 1. As a consequence all files are binary.  Normally we can distinguish between: 1. Textual files (or ASCII) (C sources, C++ sources etc..) - Binary files (Executables, Word, Excel ..)</p>"},{"location":"FileSystem/file_system/#remark","title":"Remark:","text":"<p>The UNIX/Linux kernel does not distinguish between binary and textual files.</p>"},{"location":"FileSystem/file_system/#textual-files-or-ascii-to-give-to-chatgpt-for-better-explaination","title":"Textual files (or ASCII) (to give to chatGPT for better explaination)","text":"<p>\u2756 Files consisting of data encoded in ASCII \u27a2 Sequence of 0 and 1, which (in groups of 8 bit) codify ASCII symbols \u2756 Textual files are usually \u201cline-oriented\u201d \u27a2 Newline: go to the next line \u25aa UNIX/Linux and Mac OSX \u25cf Newline = 1 character \u25cf Line Feed (go to next line, LF, 10 10) \u25aa Windows \u25cf Newline = 2 characters \u25cf Line Feed (go to next line, LF, 10 10) + Carriage Return (go to beginning of the line, CR, 13 10)</p>"},{"location":"FileSystem/file_system/#binary-files","title":"Binary Files","text":"<p>\u2756 A binary file is a sequence of 0 and 1, not \u201cbyte-oriented\u201d, meaning it's bit by bit, not byte by byte \u2756 The smallest unit that can be read/write is the bit \u27a2 Non easy the management of the single bit \u27a2 They usually include every possible sequence of 8 bits, which do not necessarily correspond to printable characters, new-line, etc.</p>"},{"location":"FileSystem/file_system/#why-are-binary-files-used","title":"Why are binary files used?","text":"<p>\u2756 Advantages \u27a2 Compactness (smaller average dimension) \u25aa Examples: Number 10000010 occupies 6 characters, (i.e., 6 bytes) in the Text/ASCII format, and 4 bytes if coded in an integer (short) \u27a2 Ease of editing the file \u25aa An integer always occupies the same space \u27a2 Ease of positioning on the file \u25aa Fixed record structure \u2756 Drawbacks \u27a2 Limited portability \u27a2 Impossibility to use a standard editor</p>"},{"location":"FileSystem/file_system/#why-are-binary-files-used_1","title":"Why are binary files used?","text":"<p>\u2756 Advantages \u27a2 Compactness (smaller average dimension) \u25aa Examples: Number 10000010 occupies 6 characters, (i.e., 6 bytes) in the Text/ASCII format, and 4 bytes if coded in an integer (short) \u27a2 Ease of editing the file \u25aa An integer always occupies the same space \u27a2 Ease of positioning on the file \u25aa Fixed record structure \u2756 Drawbacks \u27a2 Limited portability \u27a2 Impossibility to use a standard editor</p>"},{"location":"FileSystem/file_system/#serialization","title":"Serialization","text":"<p>Definition: Serialization is the process of converting a data structure (e.g., a <code>struct</code> in C) into a format that can be stored or transmitted and later reconstructed in its original form. </p> <ul> <li>Purpose: </li> <li>Allows a data structure to be stored (e.g., in a file or database)   or transmitted (e.g., over a network) as a single entity.  </li> <li>The serialized data is read and reconstructed according to the same   serialization format, ensuring the original structure is replicated.</li> </ul> <p>Features:   - Most programming languages support serialization using read/write      (R/W) operations on files. Examples include:   - Java   - Python   - Objective-C   - Ruby  </p>"},{"location":"FileSystem/file_system/#example-of-serialization-in-c","title":"Example of Serialization in C","text":"<p>Structure Definition:</p> <pre><code>struct mys {\n    int id;\n    long int rn;\n    char n[L], c[L];\n    int mark;\n} s;\n</code></pre> <p>Serialization Formats: 1. Binary Serialization:    - The structure is stored as a sequence of bytes.    - The interpretation depends on the encoding scheme (e.g., ASCII on 8 bits or Unicode on 16 bits).    - The file size is compact but not human-readable.</p> <ol> <li>Text Serialization: </li> <li>Each field is stored as text, using character encoding (e.g., ASCII on 8 bits).  </li> <li>Example: <code>1 100000 Romano Antonio 25</code></li> <li>Larger file size compared to binary serialization but more human-readable.  </li> </ol>"},{"location":"FileSystem/file_system/#notes","title":"Notes:","text":"<ul> <li>Serialization formats affect file size and readability:  </li> <li>Binary formats are compact but require decoding.  </li> <li>Text formats are larger but easy to interpret.  </li> <li>Incorrect encoding or decoding can result in malformed data (e.g., corrupted text with unrecognized characters).</li> </ul>"},{"location":"FileSystem/file_system/#io-with-the-c-standard-library","title":"I/O with the C standard library","text":"<p>I/O operations with ANSI C can be performed through different categories of functions 1. Character by character 2. Row by row 3. Formatted I/O 4. Binary I/O Read examples Write examples Binary I/O examples</p>"},{"location":"FileSystem/file_system/#iso-c-standard-library","title":"ISO C Standard Library","text":"<p>Standard I/O is \u201cfully buffered\u201d \u27a2 The I/O operation is performed only when the I/O buffer is full \u27a2 The \u201cflush\u201d operation indicates the actual write of the buffer to the I/O</p> <pre><code>#include &lt;stdio.h&gt;\nvoid setbuf (FILE *fp, char *buf);\nint fflush (FILE *fp);\n</code></pre> <p>Standard error is never buffered. For concurrent processes, use:</p> <pre><code>setbuf (stdout, 0);\nfflush (stdout);\n</code></pre>"},{"location":"FileSystem/file_system/#open-and-close-a-file","title":"Open and close a file","text":"<p>Here's how to open and close a file</p> <pre><code>#include &lt;stdio.h&gt;\nFILE *fopen (char *path, char *type);\nFILE *fclose (FILE *fp);\n</code></pre>"},{"location":"FileSystem/file_system/#access-methods","title":"Access methods","text":"<ul> <li>r, rb, w, wb, a, ab r+, r+b, etc.</li> <li>The UNIX kernel does not make any difference between textual files (ASCII) and binary files</li> <li>The \u201cb\u201d option has no effect, e.g. \u201cr\u201d==\u201crb\u201d, \u201cw\u201d==\u201cwb\u201d, etc.</li> </ul>"},{"location":"FileSystem/file_system/#io-character-by-character","title":"I/O character by character","text":"<pre><code>#include &lt;stdio.h&gt;\nint getc (FILE *fp);\nint fgetc (FILE *fp);\nint putc (int c, FILE *fp);\nint fputc (int c, FILE *fp);\n</code></pre> <p>\u2756 Returned values \u27a2 A character on success \u27a2 EOF on error, or when the end of the file is reached \u2756 The function \u27a2 getchar is equivalent to getc (stdin) \u27a2 putchar is equivalent to putc (c, stdout)</p>"},{"location":"FileSystem/file_system/#io-row-by-row","title":"I/O row by row","text":"<pre><code>#include &lt;stdio.h&gt;\nchar *gets (char *buf);\nchar *fgets (char *buf, int n, FILE *fp);\nint puts (char *buf);\nint fputs (char *buf, FILE *fp);\n</code></pre> <p>\u2756 Returned values \u27a2 buf (gets/fgets), or a non-negative value (puts/fputs) in the case of success \u27a2 NULL (gets/fgets), or EOF for errors or when the end of file is reached (puts/fputs) \u2756 Lines must be delimited by \"new-line\"</p>"},{"location":"FileSystem/file_system/#formatted-io","title":"Formatted I/O","text":"<pre><code>#include &lt;stdio.h&gt;\nint scanf (char format, ...);\nint fscanf (FILE *fp, char format, ...);\nint printf (char format, ...);\nint fprintf (FILE *fp, char format, ...);\n</code></pre> <p>\u2756 High flexibility in data manipulation \u27a2 Formats (characters, integers, reals, etc.) \u27a2 Conversions</p>"},{"location":"FileSystem/file_system/#binary-io","title":"Binary I/O","text":"<pre><code>#include &lt;stdio.h&gt;\nsize_t fread (void *ptr, size_t size,\nsize_t nObj, FILE *fp);\n\nsize_t fwrite (void *ptr, size_t size,\nsize_t nObj, FILE *fp);\n</code></pre> <p>Each I/O operation (single) operates on an aggregate object of specific size aggregate object of specific size all the fields of the struct \u27a2 With gets/puts it is not possible, because both would terminate on NULL bytes or new-lines \u2756 Returned values \u27a2 Number of objects written/read \u27a2 If the returned value does not correspond to the ferror and feof can be parameter nObj used to distinguish  \u25aa An error has occurred between the two cases  \u25aa The end of file has been reached \u2756 Often used to manage binary files \u27a2 serialized R/W (single operation for the whole struct) \u27a2 Potential problems in managing different architectures \u25aa Data format compatibility (e.g., integers, reals, etc.) \u25aa Different offsets for the fields of the struct</p>"},{"location":"FileSystem/file_system/#posix-standard-library-of-sys-calls","title":"POSIX Standard Library of sys calls","text":"<p>I/O in UNIX can be entirely performed with only 5 functions - open, read, write, lseek, close \u2756 This type of access \u27a2 Is part of POSIX and of the Single UNIX Specification, but not of ISO C \u27a2 It is normally defined with the term \"unbuffered I/O\", in the sense that each read or write operation corresponds to a system call</p>"},{"location":"FileSystem/file_system/#system-call-open","title":"System call open()","text":"<p>\u2756 In the UNIX kernel a \"file descriptor\" is a non-negative integer \u2756 Conventionally (also for shells) \u27a2 Standard input \u25aa 0 = STDIN_FILENO \u27a2 Standard output \u25aa 1 = STDOUT_FILENO \u27a2 Standard error \u25aa 2 = STDERR_FILENO These descriptors are defined in the headers file unistd.h</p>"},{"location":"FileSystem/file_system/#system-call-open_1","title":"System call open()","text":""},{"location":"FileSystem/file_system/#include","title":"include","text":""},{"location":"FileSystem/file_system/#include_1","title":"include","text":""},{"location":"FileSystem/file_system/#include_2","title":"include  <p>int open (const char path, int flags); int open (const char path, int flags, mode_t mode); \u2756 It opens a file defining the permissions \u2756 Returned values \u27a2 The descriptor of the file on success \u27a2 -1 on error</p>","text":""},{"location":"FileSystem/file_system/#system-call-open_2","title":"System call open()","text":"<p>\u2756 It can have 2 or 3 parameters \u27a2 The mode parameter is optional \u2756 Path indicates the file to open \u2756 Flags has multiple options int open ( const char *path, int flags, mode_t mode ); \u27a2 Can be obtained with the OR bit-by-bit of constants defined in the header file fcntl.h \u27a2 One of the following three constants is mandatory \u25aa O_RDONLY \u25aa O_WRONLY \u25aa O_RDWR open for read-only access open for write-only access open for read-write access</p>"},{"location":"FileSystem/file_system/#system-call-open_3","title":"System call open()","text":"<p>\u27a2 Optional constants \u25aa O_CREAT \u25aa O_EXCL \u25aa O_TRUNC \u25aa O_APPEND \u25aa O_SYNC \u25aa ... int open ( const char *path, int flags, mode_t mode ); creates the files if not exist error if O_CREAT is set and the file exists remove the content of the file append to the file each write waits that the physical write operation is finished before continuing</p>"},{"location":"FileSystem/file_system/#system-call-open_4","title":"System call open()","text":"<p>\u27a2 Optional constants \u25aa O_CREAT \u25aa O_EXCL \u25aa O_TRUNC \u25aa O_APPEND \u25aa O_SYNC \u25aa ... int open ( const char *path, int flags, mode_t mode ); creates the files if not exist error if O_CREAT is set and the file exists remove the content of the file append to the file each write waits that the physical write operation is finished before continuing</p>"},{"location":"FileSystem/file_system/#system-call-read","title":"System call read()","text":""},{"location":"FileSystem/file_system/#include_3","title":"include  <p>int read (int fd, void *buf, size_t nbytes); \u2756 Read from file fd a number of bytes equal to nbytes, storing them in buf \u2756 Returned values \u27a2 number of read bytes on success \u27a2 -1 on error \u27a2 0 in the case of EOF</p>","text":""},{"location":"FileSystem/file_system/#system-call-read_1","title":"System call read()","text":""},{"location":"FileSystem/file_system/#include_4","title":"include  <p>int read (int fd, void *buf, size_t nbytes); \u2756 The returned value is lower that nbytes \u27a2 If the end of the file is reached before nbytes bytes have been read \u27a2 If the pipe you are reading from does not contain nbytes bytes</p>","text":""},{"location":"FileSystem/file_system/#system-call-write","title":"System call write()","text":""},{"location":"FileSystem/file_system/#include_5","title":"include  <p>int write (int fd, void *buf, size_t nbytes); \u2756 Write nbytes bytes from buf in the file identified by descriptor fd \u2756 Returned values \u27a2 The number of written bytes in the case of success, i.e., normally nbytes \u27a2 -1 on error</p>","text":""},{"location":"FileSystem/file_system/#system-call-write_1","title":"System call write()","text":""},{"location":"FileSystem/file_system/#include_6","title":"include  <p>int write (int fd, void *buf, size_t nbytes); \u2756 Remark \u27a2 write writes on the system buffer, not on the disk \u25aa fd = open (file, O_WRONLY | O_SYNC); \u27a2 O_SYNC forces the sync of the buffers, but only for ext2 file systems</p> <p>Examples: File R/W float data[10]; if ( write(fd, data, 10*sizeof(float))==(-1) ) { fprintf (stderr, \"Error: Write %d).\\n\", n); } } writing of the vector data (of float) struct { char name[L]; int n; float avg; } item; if ( write(fd,&amp;item,sizeof(item)))==(-1) ) { fprintf (stderr, \"Error: Write %d).\\n\", n); } } Writing of the serialized struct item (with 3 fields)</p>","text":""},{"location":"FileSystem/file_system/#system-call-lseek","title":"System call lseek()","text":""},{"location":"FileSystem/file_system/#include_7","title":"include  <p>off_t lseek (int fd, off_t offset, int whence); \u2756 The current position of the file offset is associated to each file \u27a2 The system call lseek assigns the value offset to the file offset \u27a2 The offset value is expressed in bytes</p>","text":""},{"location":"FileSystem/file_system/#system-call-lseek_1","title":"System call lseek()","text":""},{"location":"FileSystem/file_system/#include_8","title":"include  <p>off_t lseek (int fd, off_t offset, int whence); \u2756 whence specifies the interpretation of offset \u27a2 If whence==SEEK_SET \u25aa The offset is evaluated from the beginning of the file \u27a2 If whence==SEEK_CUR \u25aa The offset is evaluated from the current position \u27a2 If whence==SEEK_END \u25aa The offset is evaluated from the end of the file The value of offset can be positive or negative It is possible to leave \"holes\" in a file (filled with zeros)</p>","text":""},{"location":"FileSystem/file_system/#system-call-lseek_2","title":"System call lseek()","text":""},{"location":"FileSystem/file_system/#include_9","title":"include  <p>off_t lseek (int fd, off_t offset, int whence); \u2756 Returned values \u27a2 new offset on success \u27a2 -1 on error</p>","text":""},{"location":"FileSystem/file_system/#system-call-close","title":"System call close()","text":""},{"location":"FileSystem/file_system/#include_10","title":"include  <p>int close (int fd); \u2756 Returned values \u27a2 0 on success \u27a2 -1 on error \u2756 All the open files are closed automatically when the process terminates</p>","text":""},{"location":"FileSystem/file_system/#example-file-rw","title":"Example: File R/W","text":"<pre><code>#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#define BUFFSIZE 4096\nint main(void) {\n    int nR, nW, fdR, fdW;\n    char buf[BUFFSIZE];\n    fdR = open (argv[1], O_RDONLY);\n    fdW = open (argv[2], O_WRONLY | O_CREAT | O_TRUNC,\n    S_IRUSR | S_IWUSR);\n    if ( fdR==(-1) || fdW==(-1) ) {\n        fprintf (stdout, \u201cError Opening a File.\\n\u201c);\n    exit (1);\n}\n</code></pre>"},{"location":"FileSystem/file_system/#example-file-rw_1","title":"Example : File R/W","text":"<p>while ( (nR = read (fdR, buf, BUFFSIZE)) &gt; 0 ) { nW = write (fdW, buf, nR); if ( nR!=nW ) fprintf (stderr, \"Error: Read %d, Write %d).\\n\", nR, nW); } if ( nR &lt; 0 ) fprintf (stderr, \"Write Error.\\n\"); close (fdR); close (fdW); exit(0); } Error check on the last reading operation This program works indifferently on text and binary files</p>"},{"location":"FileSystem/file_system_2/","title":"File System","text":""},{"location":"FileSystem/file_system_2/#file-system-overview","title":"File System Overview","text":"<p>The file system is a critical component of an Operating System (OS) providing mechanisms for permanent data storage, managing files, directories, and disk partitions.</p>"},{"location":"FileSystem/file_system_2/#files-in-linux","title":"Files in Linux","text":"<p>Files store information independently from running programs and power supply interruptions. Conceptually, files represent logically correlated information stored as contiguous address space, encoded electronically.</p>"},{"location":"FileSystem/file_system_2/#encoding-systems","title":"Encoding Systems","text":"<ul> <li>ASCII Encoding:</li> <li>A widely adopted standard using 7-bit binary to represent 128 characters, initially based on the English alphabet.</li> <li> <p>Extended ASCII expands to 8-bit, allowing for 255 characters including ISO standards like ISO 8859-1 (Latin-1).</p> </li> <li> <p>Unicode Encoding:</p> </li> <li>Supports over 110,000 characters covering virtually all existing writing systems.</li> <li>Common implementations: UCS, UTF-8 (most used, with variable-length encoding), UTF-16, and UTF-32.</li> </ul>"},{"location":"FileSystem/file_system_2/#file-types","title":"File Types","text":"<ul> <li>Textual Files (ASCII):</li> <li>Sequence of bytes readable by standard text editors.</li> <li> <p>Line-oriented, differing in newline representation between UNIX/Linux/Mac OSX (<code>LF</code>) and Windows (<code>CR</code> + <code>LF</code>).</p> </li> <li> <p>Binary Files:</p> </li> <li>Sequences of bits without line or character-oriented restrictions.</li> <li>Advantages include compactness, ease of editing, and fixed structure.</li> <li>Disadvantages include limited portability and editing difficulties.</li> </ul>"},{"location":"FileSystem/file_system_2/#serialization","title":"Serialization","text":"<p>Serialization converts structured data (e.g., C structures) into a storable format. It's crucial for consistent reading, writing, and network transmission.</p>"},{"location":"FileSystem/file_system_2/#iso-c-standard-library-for-io","title":"ISO C Standard Library for I/O","text":"<p>I/O in ANSI C provides different methods:</p> <ul> <li>Character by Character: <code>getc()</code>, <code>fgetc()</code>, <code>putc()</code>, <code>fputc()</code></li> <li>Row by Row: <code>gets()</code>, <code>fgets()</code>, <code>puts()</code>, <code>fputs()</code></li> <li>Formatted I/O: <code>scanf()</code>, <code>fscanf()</code>, <code>printf()</code>, <code>fprintf()</code></li> <li>Binary I/O: <code>fread()</code>, <code>fwrite()</code> for serialized data storage and retrieval, common for binary files.</li> </ul> <p>Buffered I/O operations store data temporarily and flush it to disk periodically or explicitly (<code>fflush()</code>).</p>"},{"location":"FileSystem/file_system_2/#file-access-and-operations","title":"File Access and Operations","text":"<ul> <li>Opening and Closing Files:</li> <li>Using <code>fopen()</code> and <code>fclose()</code>, files can be accessed with modes such as read (<code>r</code>), write (<code>w</code>), append (<code>a</code>).</li> <li>In UNIX/Linux, there's no functional difference between text (<code>\"r\"</code>) and binary (<code>\"rb\"</code>) modes.</li> </ul>"},{"location":"FileSystem/file_system_2/#posix-standard-library-unbuffered-io","title":"POSIX Standard Library (Unbuffered I/O)","text":"<p>Unbuffered I/O involves direct system calls with immediate effect, using mainly five operations:</p> <ul> <li><code>open()</code>:</li> <li>Opens or creates files, specifying access modes (e.g., <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>).</li> <li> <p>Optional flags include creation (<code>O_CREAT</code>), truncation (<code>O_TRUNC</code>), synchronization (<code>O_SYNC</code>), and permission settings (<code>S_IRUSR</code>, <code>S_IWUSR</code>).</p> </li> <li> <p><code>read()</code>:</p> </li> <li> <p>Reads a specified number of bytes from files, returning the actual bytes read or zero at EOF.</p> </li> <li> <p><code>write()</code>:</p> </li> <li> <p>Writes bytes to files, returning bytes written; can synchronize immediately with <code>O_SYNC</code>.</p> </li> <li> <p><code>lseek()</code>:</p> </li> <li> <p>Adjusts the current offset within a file, supporting positioning relative to start (<code>SEEK_SET</code>), current position (<code>SEEK_CUR</code>), or end (<code>SEEK_END</code>). Can create sparse files.</p> </li> <li> <p><code>close()</code>:</p> </li> <li>Releases file descriptors; occurs automatically at program termination.</li> </ul>"},{"location":"FileSystem/file_system_2/#example-usage","title":"Example Usage","text":"<p>Provided examples demonstrate typical use cases of file reading/writing in C, handling both textual and binary files, with careful error checking and system calls implementation.</p> <p>This overview captures the essence and comprehensive details of managing files in a UNIX/Linux environment, emphasizing both the logical structure and practical usage through standardized functions and system calls.</p>"},{"location":"FileSystem/file_system_refined/","title":"File system refined","text":""},{"location":"FileSystem/file_system_refined/#information-storage","title":"Information Storage","text":""},{"location":"FileSystem/file_system_refined/#overview","title":"Overview","text":"<p>Information storage allows data to be preserved across time, unaffected by various disruptions such as program termination, power loss, or system crashes. Files, as logical entities, encapsulate data in a structured format that is encoded for efficient storage and retrieval.</p>"},{"location":"FileSystem/file_system_refined/#logical-perspective-on-files","title":"Logical Perspective on Files","text":"<p>A file is a structured repository of related data, characterized by: 1. Content: Numbers, text, images, and other data types stored using standardized encoding systems. 2. Storage: Represented as a sequence of bytes within a contiguous address space on a storage medium.</p>"},{"location":"FileSystem/file_system_refined/#encoding-systems","title":"Encoding Systems","text":""},{"location":"FileSystem/file_system_refined/#ascii-american-standard-code-for-information-interchange","title":"ASCII (American Standard Code for Information Interchange)","text":"<ol> <li>Original ASCII:  </li> <li>Contains 128 characters.</li> <li>Includes 32 non-printable control characters and 96 printable symbols.</li> <li> <p>Encoded using 7 bits per character.</p> </li> <li> <p>Extended ASCII:  </p> </li> <li>Extends the standard to 8 bits, accommodating 255 characters.</li> <li>Variants include:<ul> <li>ISO 8859-1 (Latin-1): Western European languages.</li> <li>ISO 8859-5: Cyrillic alphabet.</li> <li>Others for Eastern European and additional languages.</li> </ul> </li> </ol>"},{"location":"FileSystem/file_system_refined/#unicode","title":"Unicode","text":"<ol> <li>Purpose: Industrial standard designed to represent characters from all writing systems.</li> <li>Key Features:</li> <li>Over 110,000 characters.</li> <li>Includes symbols and scripts across various languages.</li> <li>Implementations:</li> <li>UTF-8: Variable-length encoding (1-4 bytes).<ul> <li>Backward-compatible with ASCII for the first 128 characters.</li> </ul> </li> <li>UTF-16: Variable-length encoding (2-4 bytes).</li> <li>UTF-32: Fixed-length encoding (4 bytes).</li> </ol>"},{"location":"FileSystem/file_system_refined/#file-types","title":"File Types","text":"<ol> <li>Textual Files:  </li> <li>Encoded in ASCII or similar formats.</li> <li> <p>Line-oriented (e.g., newline characters for line breaks differ by OS).</p> <ul> <li>Unix/Linux: LF (<code>\\n</code>).</li> <li>Windows: CR+LF (<code>\\r\\n</code>).</li> </ul> </li> <li> <p>Binary Files:  </p> </li> <li>Store raw byte sequences, not limited to printable characters.</li> <li>Compact and efficient for numeric data or executables.</li> <li>Advantages:<ul> <li>Smaller size.</li> <li>Fixed structure simplifies file editing and navigation.</li> </ul> </li> <li>Drawbacks:<ul> <li>Limited portability.</li> <li>Cannot be directly edited using standard text editors.</li> </ul> </li> </ol>"},{"location":"FileSystem/file_system_refined/#serialization","title":"Serialization","text":"<p>Serialization converts complex data structures into storable or transmittable formats: 1. Encodes data as a sequential stream of bytes. 2. Enables reconstruction of the original structure during deserialization. 3. Supported in programming languages like Java, Python, and Ruby.</p>"},{"location":"FileSystem/file_system_refined/#file-io-in-c","title":"File I/O in C","text":""},{"location":"FileSystem/file_system_refined/#standard-library-functions","title":"Standard Library Functions","text":"<ol> <li>Open and Close:</li> <li><code>fopen()</code>: Opens a file.</li> <li> <p><code>fclose()</code>: Closes a file.</p> </li> <li> <p>Character-by-Character I/O:</p> </li> <li> <p><code>getc()</code>, <code>putc()</code>: Read/write single characters.</p> </li> <li> <p>Line-by-Line I/O:</p> </li> <li> <p><code>fgets()</code>, <code>fputs()</code>: Read/write entire lines.</p> </li> <li> <p>Formatted I/O:</p> </li> <li> <p><code>printf()</code>, <code>scanf()</code>: Process data in specified formats.</p> </li> <li> <p>Binary I/O:</p> </li> <li><code>fread()</code>, <code>fwrite()</code>: Operate on blocks of data.</li> </ol>"},{"location":"FileSystem/file_system_refined/#posix-system-calls","title":"POSIX System Calls","text":"<p>For low-level, unbuffered file access: - open(): Opens a file and returns a descriptor. - read(): Reads bytes from a file. - write(): Writes bytes to a file. - lseek(): Adjusts the file pointer. - close(): Closes the file descriptor.</p>"},{"location":"FileSystem/file_system_refined/#key-concepts-in-binary-io","title":"Key Concepts in Binary I/O","text":"<ol> <li>Binary files often store serialized data, enabling compact storage.</li> <li>Compatibility issues may arise due to varying architectures (e.g., byte order, field alignment).</li> </ol> <p>This structured explanation bridges technical details with conceptual clarity, covering the essential aspects of information storage and file management. Let me know if you'd like to expand on specific sections or require examples!</p>"},{"location":"FileSystem/write/","title":"The <code>write</code> syscall","text":""},{"location":"FileSystem/write/#file-descriptors","title":"File Descriptors","text":"<p>In UNIX\u2010style operating systems (Linux, BSD, macOS), every process maintains a small table of file descriptors\u2014non-negative integers that act as opaque handles to I/O resources (files, pipes, sockets, devices, etc.).  By convention, the first three entries of this table are reserved:</p> <p>0 \u2192 STDIN_FILENO Standard input; by default reads from the terminal or whatever is piped in.</p> <p>1 \u2192 STDOUT_FILENO Standard output; by default writes to the terminal.</p> <p>2 \u2192 STDERR_FILENO Standard error; also writes to the terminal but typically unbuffered, for error messages.</p>"},{"location":"IOprimitives/Generalities/","title":"I/O made with <code>&lt;stdio.h&gt;</code>","text":"<ul> <li>Casting in C</li> <li>Functions in C</li> <li>Structs and typedef in C</li> <li>File Reading</li> <li>File Writing</li> <li>Command line arguments</li> <li>Writing and Reading a binary file</li> </ul>"},{"location":"IOprimitives/Generalities/#syscalls-to-manage-files-in-linux","title":"Syscalls to manage files in Linux","text":""},{"location":"IOprimitives/Generalities/#arguments-passed-on-the-command-line","title":"Arguments passed on the command line","text":"<pre><code>int main(int argc, char *argv[]);\n</code></pre> <ul> <li><code>argv[0]</code> is the string your operating system uses to invoke the program (often the path or name of the executable).</li> <li><code>argv[1]</code> is the first actual command-line argument you passed.</li> <li><code>argv[2]</code> would be the second argument, and so on, up to <code>argv[argc-1]</code>.</li> </ul> <p>So if you run</p> <pre><code>./a.out 4\n</code></pre> <p>then inside <code>main</code>:</p> <ul> <li><code>argc == 2</code>,</li> <li><code>argv[0]</code> points to <code>\"./a.out\"</code>,</li> <li><code>argv[1]</code> points to <code>\"4\"</code>.</li> </ul> <p>Be careful: if you access <code>argv[1]</code> without checking that <code>argc &gt; 1</code>, you\u2019ll invoke undefined behavior when no argument was provided.</p>"},{"location":"IOprimitives/theory_IOprimitives_1/","title":"I/O Primitives in C, part I","text":""},{"location":"IOprimitives/theory_IOprimitives_1/#accepting-cli-arguments","title":"Accepting CLI arguments:","text":"<pre><code>int main(int argc, char ** argv){\n    // in the code, to call them: argv[1], argv[2] ...\n    // argv[0] is the name of the executable itself, say, \"a.out\"\n    // so it goes: ./a.out argument1 argument2 ..\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_1/#char-vectors","title":"Char vectors","text":"<p>1 char = 1 byte</p> <pre><code>char name[1024];\n</code></pre> <p>Strings in C end in a NULL element. So the maximum number that can be contained in a [1024] vector of char is 1023 char, plus the NULL element \"\\0\".</p> <p>[1024] is the contiguos number of char allocated on the stack.</p>"},{"location":"IOprimitives/theory_IOprimitives_1/#buffers","title":"Buffer(s)","text":"<p>A buffer is a temporary storage space used to read files, to perform I/O operations or to manipulate data.</p>"},{"location":"IOprimitives/theory_IOprimitives_1/#overview-on-the-io-primitives","title":"Overview on the I/O primitives","text":"<p>These are standard ANSI C I/O functions for file operations</p>"},{"location":"IOprimitives/theory_IOprimitives_1/#comparison-of-their-uses","title":"Comparison of Their Uses","text":"Function Purpose Level of Operation fgetc Read a single character Character-based fputc Write a single character Character-based fscanf Read formatted data Formatted input fprintf Write formatted data Formatted output fgets Read a string/line Line or string-based fputs Write a string/line Line or string-based"},{"location":"IOprimitives/theory_IOprimitives_1/#when-to-use-which","title":"When to Use Which","text":"<ul> <li><code>fgetc</code> and <code>fputc</code>:</li> <li> <p>Use when you need to process files character by character, such as counting    characters or detecting specific ones.</p> </li> <li> <p><code>fscanf</code> and <code>fprintf</code>:</p> </li> <li> <p>Use when working with structured data where formatting matters (e.g., reading    integers, floats, or a mix of types from a file).</p> </li> <li> <p><code>fgets</code> and <code>fputs</code>:</p> </li> <li>Use when working with text files line-by-line or dealing with strings.</li> </ul>"},{"location":"IOprimitives/theory_IOprimitives_1/#sprintf","title":"<code>sprintf</code>","text":"<p>The function <code>sprintf</code> writes formatted (by you) data to a string, instead of standard output, like <code>printf</code> does.</p> <pre><code>char name[1024];\n\nsprintf(name, \"%s.1\", argv[2]);\n</code></pre> <p>say argv[2] is <code>test</code>, then it writes onto name the string: <code>test.1</code></p>"},{"location":"IOprimitives/theory_IOprimitives_1/#reading-a-file-using-fscanf","title":"Reading a file using <code>fscanf</code>","text":"<pre><code>FILE *destination, *source;\nchar c;\n\nwhile(fscanf(source, \"%c\", &amp;c) != EOF){\n    fprintf(destination, \"%c\", c);\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_2/","title":"I/O Primitives in C, part II","text":""},{"location":"IOprimitives/theory_IOprimitives_2/#fgetcfputc","title":"fgetc/fputc","text":"<p>The following is one whole program that reads char-by-char from a file and write said content onto another one</p> <pre><code>#include &lt;stdio.h&gt;\nint main (int argc, char **argv) { // This line allows me to execute this program on the prompt by accepting CL arguments\n  FILE *fs, *fd;\n  char c;\n  char name[1024];\n\n  // Solution using fgetc and fputc\n  sprintf (name, \"%s.2\", argv[2]);\n  fs = fopen(argv[1], \"r\");\n  fd = fopen(name, \"w\");\n  while ((c = fgetc(fs)) != EOF) {\n    fputc (c, fd);\n  }\n  fclose(fs);\n  fclose(fd);\n\n  return 0;\n}\n</code></pre> <p>This is the portion worth analizing</p> <pre><code>  fs = fopen(argv[1], \"r\");\n  fd = fopen(name, \"w\");\n  while ((c = fgetc(fs)) != EOF) {\n    fputc (c, fd);\n  }\n</code></pre> <ul> <li><code>c = fgetc(fs)</code>: reads the \"next\" char from the file \"fs\" and stores it into the <code>char c</code> variable</li> <li><code>(c = fgetc(fs)) != EOF</code>: the expression <code>(c = fgetc(fs))</code> is equivalent to a single char type variable, when it is not a EOF variable</li> <li><code>fputc(c, fd);</code>: writes the <code>char c</code> onto fd</li> </ul>"},{"location":"IOprimitives/theory_IOprimitives_2/#fscanffprintf","title":"fscanf/fprintf","text":""},{"location":"IOprimitives/theory_IOprimitives_2/#fgetsfputs","title":"fgets/fputs","text":""},{"location":"IOprimitives/theory_IOprimitives_3/","title":"I/O Primitives in C, part III","text":""},{"location":"IOprimitives/theory_IOprimitives_3/#binary-io","title":"Binary I/O","text":""},{"location":"IOprimitives/theory_IOprimitives_3/#fread","title":"<code>fread</code>","text":""},{"location":"IOprimitives/theory_IOprimitives_3/#fwrite","title":"<code>fwrite</code>","text":""},{"location":"IOprimitives/theory_IOprimitives_4/","title":"POSIX system calls for File Handling, part IV","text":"<p>The POSIX system calls <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close()</code> are low-level file operations used in C programming to interact with files. They provide direct interaction with the operating system and are included in <code>&lt;fcntl.h&gt;</code> and <code>&lt;unistd.h&gt;</code>. Below is an explanation of how to use each of these system calls, with examples.</p>"},{"location":"IOprimitives/theory_IOprimitives_4/#1-open","title":"1. <code>open()</code>","text":"<p>The <code>open()</code> system call opens a file for reading, writing, or both. It returns a file descriptor (an integer) that is used in subsequent file operations.</p>"},{"location":"IOprimitives/theory_IOprimitives_4/#syntax","title":"Syntax","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nint open(const char *pathname, int flags, mode_t mode);\n</code></pre> <ul> <li><code>pathname</code>: The file to open (e.g., <code>\"file.txt\"</code>).</li> <li><code>flags</code>: Specifies the access mode:</li> <li><code>O_RDONLY</code>: Open for reading.</li> <li><code>O_WRONLY</code>: Open for writing.</li> <li><code>O_RDWR</code>: Open for reading and writing.</li> <li>Add flags like <code>O_CREAT</code> (create file if it doesn\u2019t exist) or <code>O_APPEND</code> (append mode).</li> <li><code>mode</code>: File permissions (only used if creating a file, e.g., <code>0644</code> for <code>rw-r--r--</code>).</li> </ul>"},{"location":"IOprimitives/theory_IOprimitives_4/#example","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    int fd = open(\"example.txt\", O_WRONLY | O_CREAT, 0644);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    // Use `fd` for further operations\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_4/#2-read","title":"2. <code>read()</code>","text":"<p>The <code>read()</code> system call reads data from a file into a buffer.</p>"},{"location":"IOprimitives/theory_IOprimitives_4/#syntax_1","title":"Syntax","text":"<pre><code>ssize_t read(int fd, void *buf, size_t count);\n</code></pre> <ul> <li><code>fd</code>: File descriptor returned by <code>open()</code>.</li> <li><code>buf</code>: Buffer to store the data.</li> <li><code>count</code>: Number of bytes to read.</li> <li>Returns: Number of bytes actually read, or <code>0</code> if end-of-file (EOF) is reached.</li> </ul>"},{"location":"IOprimitives/theory_IOprimitives_4/#example_1","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char buffer[128];\n    int fd = open(\"example.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1);\n    if (bytesRead == -1) {\n        perror(\"read\");\n        close(fd);\n        return 1;\n    }\n    buffer[bytesRead] = '\\0'; // Null-terminate the buffer\n    printf(\"Read: %s\\n\", buffer);\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_4/#3-write","title":"3. <code>write()</code>","text":"<p>The <code>write()</code> system call writes data from a buffer to a file.</p>"},{"location":"IOprimitives/theory_IOprimitives_4/#syntax_2","title":"Syntax","text":"<pre><code>ssize_t write(int fd, const void *buf, size_t count);\n</code></pre> <ul> <li><code>fd</code>: File descriptor returned by <code>open()</code>.</li> <li><code>buf</code>: Buffer containing the data to write.</li> <li><code>count</code>: Number of bytes to write.</li> <li>Returns: Number of bytes written.</li> </ul>"},{"location":"IOprimitives/theory_IOprimitives_4/#example_2","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    const char *text = \"Hello, world!\\n\";\n    int fd = open(\"example.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    ssize_t bytesWritten = write(fd, text, 14);\n    if (bytesWritten == -1) {\n        perror(\"write\");\n        close(fd);\n        return 1;\n    }\n    printf(\"Wrote %zd bytes\\n\", bytesWritten);\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_4/#4-close","title":"4. <code>close()</code>","text":"<p>The <code>close()</code> system call closes an open file descriptor, releasing the resources associated with it.</p>"},{"location":"IOprimitives/theory_IOprimitives_4/#syntax_3","title":"Syntax","text":"<pre><code>int close(int fd);\n</code></pre> <ul> <li><code>fd</code>: File descriptor to close.</li> <li>Returns: <code>0</code> on success, or <code>-1</code> on failure.</li> </ul>"},{"location":"IOprimitives/theory_IOprimitives_4/#example_3","title":"Example","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    int fd = open(\"example.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n    // Perform file operations...\n    if (close(fd) == -1) {\n        perror(\"close\");\n        return 1;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_4/#complete-example-file-copy-program","title":"Complete Example: File Copy Program","text":"<p>Here's a small program that copies the content of one file to another:</p> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char buffer[1024];\n    ssize_t bytesRead, bytesWritten;\n\n    // Open source file\n    int source = open(\"source.txt\", O_RDONLY);\n    if (source == -1) {\n        perror(\"open source\");\n        return 1;\n    }\n\n    // Open destination file\n    int dest = open(\"dest.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (dest == -1) {\n        perror(\"open dest\");\n        close(source);\n        return 1;\n    }\n\n    // Read and write loop\n    while ((bytesRead = read(source, buffer, sizeof(buffer))) &gt; 0) {\n        bytesWritten = write(dest, buffer, bytesRead);\n        if (bytesWritten != bytesRead) {\n            perror(\"write\");\n            close(source);\n            close(dest);\n            return 1;\n        }\n    }\n    if (bytesRead == -1) {\n        perror(\"read\");\n    }\n\n    // Close files\n    close(source);\n    close(dest);\n    return 0;\n}\n</code></pre>"},{"location":"IOprimitives/theory_IOprimitives_4/#notes","title":"Notes:","text":"<ul> <li>Always check the return values of these calls for errors.</li> <li>Errors can be inspected using <code>errno</code> and printed with <code>perror()</code> or <code>strerror()</code>.</li> <li>File permissions (e.g., <code>0644</code>) are written in octal.</li> </ul> <p>Let me know if you have further questions!</p>"},{"location":"Processes/Process_ID/","title":"Process ID","text":""},{"location":"Processes/Process_ID/#concurrent-v-parallel","title":"Concurrent v. Parallel","text":"<ul> <li> <p>Concurrent programming is about structure and management: handling multiple tasks by interleaving execution to improve responsiveness.</p> </li> <li> <p>Parallel computing is about performance and speed: dividing computations to physically run them simultaneously across multiple processors.</p> </li> </ul>"},{"location":"Processes/Process_ID/#1-uid-and-gid","title":"1. UID and GID","text":"<ul> <li>UID (User ID): Identifies a user uniquely on a Unix/Linux system.</li> <li>GID (Group ID): Identifies the user's primary group on the system.</li> </ul> <p>The functions:</p> <pre><code>uid_t getuid();\ngid_t getgid();\n</code></pre> <p>These retrieve the real user ID and real group ID of the process, respectively. The \"real\" IDs typically represent the user who initiated the process.</p>"},{"location":"Processes/Process_ID/#2-effective-uid-and-effective-gid","title":"2. Effective UID and Effective GID","text":"<p>In addition to the real IDs, processes have an Effective UID (EUID) and Effective GID (EGID).</p> <ul> <li>Effective UID (EUID) determines the permissions for file access and actions the process can perform.</li> <li>Effective GID (EGID) affects group-level permissions.</li> </ul> <p>The functions:</p> <pre><code>uid_t geteuid();\ngid_t getegid();\n</code></pre> <p>retrieve the effective user and group IDs, respectively.</p>"},{"location":"Processes/Process_ID/#3-practical-example-passwd-command","title":"3. Practical Example (passwd Command)","text":"<p>A typical example of this mechanism is the <code>passwd</code> command:</p> <ul> <li>Changing a user's password involves modifying sensitive system files, which typically only root can access.</li> <li>The <code>passwd</code> command needs temporary elevated permissions to perform this task, even if executed by a regular user.</li> <li>Therefore, <code>passwd</code> has the SetUID bit set. When executed, the operating system temporarily grants the command the Effective UID of the file's owner (usually root).</li> <li>Consequently, even though the Real UID remains the user running the command, the Effective UID is temporarily elevated to root to complete the task.</li> </ul> <p>Example scenario: - Normal user executes: <code>passwd</code> - System recognizes the SetUID bit on <code>/usr/bin/passwd</code></p> <ul> <li>Command runs with root permissions to change the password.</li> <li>After execution, privileges are dropped back to normal user levels.</li> </ul>"},{"location":"Processes/Process_ID/#in-short","title":"In Short:","text":"<ul> <li>UID/GID \u2192 identity of the user/process.</li> <li>Effective UID/GID \u2192 permissions a process uses to interact with system resources.</li> <li>SetUID/SetGID bit \u2192 allows temporary privilege elevation, crucial for secure system operations.</li> </ul> <p>This mechanism is key to balancing security and usability in Unix/Linux systems.</p>"},{"location":"Processes/Process_ID/#operative-example","title":"Operative Example","text":"<p>This output</p> <pre><code>Process ID (PID): 22153\nParent Process ID (PPID): 21767\nUser ID (UID): 1000\nGroup ID (GID): 1000\nEffective User ID (EUID): 1000\nEffective Group ID (EGID): 1000\n</code></pre> <p>means</p> <pre><code>Explanation of your output:\nPID (Process ID):\n22153 is the unique identifier assigned by the system to your running process.\n\nPPID (Parent Process ID):\n21767 identifies the parent process which launched your current program (often your shell, IDE, or terminal).\n\nUser ID (UID):\n1000 usually indicates a standard, non-root user account (the first user account created in a Unix/Linux system is commonly assigned UID 1000).\n\nGroup ID (GID):\n1000 is your default user group, typically matching your UID.\n\nEffective User ID (EUID) and Effective Group ID (EGID):\nBoth 1000, indicating that no special privileges or changes to identity have been made to your program at this point.\n</code></pre>"},{"location":"Shell/Find/","title":"Looking for things across the Filesystem","text":""},{"location":"Shell/Find/#regular-expressions","title":"Regular Expressions","text":"<p>We'll se Basic Regular Expressions (BRE) and Extended Regular Expressions (ERE)</p>"},{"location":"Shell/Find/#find","title":"Find","text":"<p>To look for a file in the entire Linux system, you can use several commands, but the most common and effective one is <code>find</code>. Here are some methods:</p>"},{"location":"Shell/Find/#using-find","title":"Using <code>find</code>","text":"<p>The <code>find</code> command is very powerful and flexible for searching files based on various criteria.</p>"},{"location":"Shell/Find/#searching-just-a-file-in-the-filesystem","title":"Searching just a file in the Filesystem","text":"<p>To search for a file named <code>filename.txt</code> starting from the root directory <code>/</code>:</p> <pre><code>sudo find / -name \"filename.txt\"\n</code></pre> <ul> <li><code>sudo</code> is used to ensure you have the necessary permissions to search in all directories.</li> <li><code>/</code> specifies the starting directory (root directory in this case).</li> <li><code>-name</code> specifies the name of the file you're looking for.</li> </ul>"},{"location":"Shell/Find/#case-insensitive-search-of-a-file-in-the-filesystem","title":"Case-Insensitive Search of a file in the Filesystem","text":"<p>To search without case sensitivity:</p> <pre><code>sudo find / -iname \"filename.txt\"\n</code></pre> <ul> <li><code>-iname</code> performs a case-insensitive search.</li> </ul>"},{"location":"Shell/Find/#searching-for-a-specific-directory","title":"Searching for a specific directory","text":"<p>To search for directories named <code>mydir</code>:</p> <pre><code>sudo find / -type d -name \"mydir\"\n</code></pre> <ul> <li><code>-type d</code> restricts the search to directories.</li> </ul>"},{"location":"Shell/Find/#searching-for-a-regular-file","title":"Searching for a regular file","text":"<p>To search for regular files named <code>filename.txt</code>:</p> <pre><code>sudo find / -type f -name \"filename.txt\"\n</code></pre> <ul> <li><code>-type f</code> restricts the search to regular files.</li> </ul>"},{"location":"Shell/Find/#searching-by-modification-time","title":"Searching by Modification Time","text":"<p>To find files modified in the last 7 days:</p> <pre><code>sudo find / -type f -mtime -7\n</code></pre> <ul> <li><code>-mtime -7</code> finds files modified within the last 7 days.</li> </ul>"},{"location":"Shell/Find/#executing-commands-on-found-files","title":"Executing Commands on Found Files","text":"<p>To delete all <code>.tmp</code> files found:</p> <pre><code>sudo find / -type f -name \"*.tmp\" -exec rm -f {} \\;\n</code></pre> <ul> <li><code>-exec rm -f {} \\;</code> executes the <code>rm -f</code> command on each found file.</li> </ul>"},{"location":"Shell/Find/#using-locate","title":"Using <code>locate</code>","text":"<p>The <code>locate</code> command is another fast way to find files, but it depends on a database that is usually updated daily.</p>"},{"location":"Shell/Find/#basic-usage","title":"Basic Usage","text":"<p>To find a file named <code>filename.txt</code>:</p> <pre><code>locate filename.txt\n</code></pre>"},{"location":"Shell/Find/#updating-the-database","title":"Updating the Database","text":"<p>To ensure the database is up-to-date, run:</p> <pre><code>sudo updatedb\n</code></pre> <p>Then you can use <code>locate</code> again to search for files.</p>"},{"location":"Shell/Find/#find-and-grep","title":"Find and Grep","text":""},{"location":"Shell/Find/#using-find-with-grep","title":"Using <code>find</code> with <code>grep</code>","text":"<p>For more complex searches, combining <code>find</code> with <code>grep</code> can be very effective.</p>"},{"location":"Shell/Find/#example-searching-by-file-content","title":"Example: Searching by File Content","text":"<p>To find files containing the text \"example\" within <code>/etc</code>:</p> <pre><code>sudo find /etc -type f -exec grep -l \"example\" {} \\;\n</code></pre> <ul> <li><code>grep -l \"example\" {}</code> prints the names of files containing the text \"example\".</li> </ul>"},{"location":"Shell/Find/#using-fd-if-installed","title":"Using <code>fd</code> (if installed)","text":"<p>The <code>fd</code> command is a simpler and faster alternative to <code>find</code>.</p>"},{"location":"Shell/Find/#basic-usage_1","title":"Basic Usage","text":"<p>To search for a file named <code>filename.txt</code>:</p> <pre><code>fd filename.txt /\n</code></pre>"},{"location":"Shell/PermissionManagement/","title":"Permission Management","text":"<p>Managing permissions in a Linux system is a crucial task for ensuring security and proper access control. This tutorial will guide you through verifying your username and group, exploring the file system structure, understanding directory access rights, and modifying permissions using both numeric (octal) and symbolic methods.</p>"},{"location":"Shell/PermissionManagement/#verifying-your-username-and-group","title":"Verifying Your Username and Group","text":"<p>To check your username and group, use the following commands:</p> <ul> <li> <p><code>who</code> Command: Displays your login name and other session information.   <code>shell   who</code></p> </li> <li> <p><code>groups</code> Command: Shows the groups you belong to.   <code>shell   groups</code></p> </li> </ul> <p>Is it possible to modify them? Yes, it is possible to modify your username or group if you have the required administrative rights.  For example, a user with root privileges can use the <code>usermod</code> command to change a username or group.</p> <p>Example:</p> <pre><code>sudo usermod -l new_username old_username\nsudo usermod -g new_group username\n</code></pre>"},{"location":"Shell/PermissionManagement/#checking-permissions-on-directories","title":"Checking Permissions on Directories","text":"<p>To check the read, write, and execute permissions on various directories, use the following command:</p> <pre><code>ls -l /home\n</code></pre> <p>This will show you a detailed list of directories in /home with their permissions, owners, and groups. For example:</p> <pre><code>drwxr-xr-x  2 user1 user1 4096 Dec  4 10:00 user1\n</code></pre> <ul> <li>The first column shows the permissions (drwxr-xr-x).</li> <li>The second column shows the owner (user1).</li> <li>The third column shows the group (user1).</li> </ul> <p>To see the permissions for a specific directory or file, use:</p> <pre><code>ls -l /home/user1\n</code></pre> <p>This will list the permissions, owner, and group for files and directories within /home/user1.</p>"},{"location":"Shell/PermissionManagement/#modifying-permissions-on-directories","title":"Modifying Permissions on Directories","text":"<p>You can change permissions using the <code>chmod</code> command.</p>"},{"location":"Shell/PermissionManagement/#symbolic-permissions","title":"Symbolic Permissions","text":"<p>To modify access rights using symbolic notation, you can add or remove specific rights for the user (u), group (g), and others (o). For example:</p> <ul> <li>Remove read permission from others:</li> </ul> <p><code>bash   chmod o-r /home/user1</code></p> <ul> <li>Add write permission for the user:</li> </ul> <p><code>bash   chmod u+w /home/user1</code></p>"},{"location":"Shell/PermissionManagement/#numeric-octal-permissions","title":"Numeric (Octal) Permissions","text":"<p>You can also use numeric values to modify permissions. The octal notation corresponds to the following:</p> <ul> <li><code>r</code> (read) = 4</li> <li><code>w</code> (write) = 2</li> <li><code>x</code> (execute) = 1</li> </ul> <p>Permissions are represented as a three-digit number: <code>rwxr-xr-x</code> becomes <code>755</code>.</p> <p>Example:</p> <ul> <li>Setting <code>755</code> permissions (read, write, execute for the owner, and read and execute for group and others):</li> </ul> <p><code>bash   chmod 755 /home/user1</code></p>"},{"location":"Shell/PermissionManagement/#removing-read-or-execution-rights-for-a-directory","title":"Removing Read or Execution Rights for a Directory","text":"<p>If you want to remove read or execute permissions for a directory, use:</p>"},{"location":"Shell/PermissionManagement/#using-symbolic-notation","title":"Using Symbolic Notation:","text":"<ul> <li>Remove read permission from everyone:</li> </ul> <p><code>bash   chmod a-r /home/user1</code></p> <ul> <li>Remove execute permission for group:</li> </ul> <p><code>bash   chmod g-x /home/user1</code></p>"},{"location":"Shell/PermissionManagement/#using-octal-notation","title":"Using Octal Notation:","text":"<ul> <li>Remove execute permission (equivalent to <code>rwxr-xr-x</code> to <code>rw-r--r--</code>):</li> </ul> <p><code>bash   chmod 644 /home/user1</code></p>"},{"location":"Shell/PermissionManagement/#recursively-modifying-permissions","title":"Recursively Modifying Permissions","text":"<p>To modify the permissions of all files and subdirectories within a directory tree, use the <code>-R</code> (recursive) option.</p> <p>For example, to remove read access for all users (owner, group, and others) from the directory <code>osEx01backup</code>, use:</p> <pre><code>chmod -R a-r /path/to/osEx01backup\n</code></pre> <p>This will apply the changes to all files and subdirectories inside <code>osEx01backup</code>.</p>"},{"location":"Shell/PermissionManagement/#summary-of-common-commands","title":"Summary of Common Commands","text":"<ul> <li>View current username and groups:</li> </ul> <p><code>bash   who   groups</code></p> <ul> <li>View the structure of the <code>/home</code> directory:</li> </ul> <p><code>bash   ls /home</code></p> <ul> <li>Check detailed directory permissions:</li> </ul> <p><code>bash   ls -l /home</code></p> <ul> <li>Modify permissions (symbolic):</li> </ul> <p><code>bash   chmod u+x /home/user1   # Add execute permission to user   chmod g-w /home/user1   # Remove write permission from group   chmod a-r /home/user1   # Remove read permission from everyone</code></p> <ul> <li>Modify permissions (numeric):</li> </ul> <p><code>bash   chmod 755 /home/user1   # Set rwx for owner, rx for group and others   chmod 644 /home/user1   # Set rw- for owner, r-- for group and others</code></p> <ul> <li>Recursively modify permissions:</li> </ul> <p><code>bash   chmod -R a-r /path/to/osEx01backup  # Remove read permission for all in osEx01backup</code></p>"},{"location":"Shell/command_line/","title":"Commands","text":"<ul> <li>Introduction to Bash Scripting</li> </ul>"},{"location":"Shell/command_line/#the-diff-command","title":"The diff command","text":""},{"location":"Shell/command_line/#hard-links-and-soft-links","title":"Hard Links and Soft Links","text":"<p>The <code>ln</code> command allows to create hard and soft links.</p>"},{"location":"Shell/command_line/#copy-a-directory-tree-recursively","title":"Copy a directory tree recursively","text":"<pre><code>cp -r ~/soEx01 ~/soEx01backup # copy it recursively\nrm -r ~/soEx01 # remove it recursively\n</code></pre>"},{"location":"Shell/command_line/#wc-word-count-command","title":"wc (word count) command","text":"<p><code>wc</code> prints the number of rows, words, and characters of the file passed as argument, respectively</p> <pre><code>wc lab01e01in.txt \n100  467 3114 lab01e01in.txt\n</code></pre>"},{"location":"Shell/command_line/#the-history","title":"The history","text":"<p>Prints the last commands executed in the terminal</p> <pre><code>history\n</code></pre>"},{"location":"Threads/pthreads/","title":"POSIX threads or <code>pthreads</code>","text":"<p>A thread is a function that is executed in concurrency with the main thread A process with multiple threads = a set of independently executing functions that share the process resources</p> <p>The Pthreads library allows 1. Creating and manipulating threads 2. Synchronizing threads 3. Protection of resources shared by threads 4. Thread scheduling 5. Destroying thread</p> <p>It defines more than 60 functions 1. All functions have a <code>pthread_*</code> prefix 2. <code>pthread_equal</code>, <code>pthread_self</code>, <code>pthread_create</code>, <code>pthread_exit</code>, <code>pthread_join</code>, <code>pthread_cancel</code>, <code>pthread_detach</code></p> <p>The Pthread system calls are defined in 1. pthreads.h 2. It is necessary to remember 3. To insert in the .c files 4. <code>#include &lt;pthread.h&gt;</code> 5. Compile your program linking the pthread library 6. <code>gcc -Wall -g -o &lt;exeName&gt; &lt;file.c&gt; -lpthread</code></p> <p>A thread is uniquely identified 1. By a type identifier pthread_t 2. Similar to the PID of a process (pid_t) 3. The type pthread_t is opaque 4. Its definition is implementation dependent 5. Can be used only by functions specifically defined in Pthreads 6. It is not possible compare directly two identifiers or print their values 7. It has meaning only within the process where the thread is executed 8. Remember that the PID is global within the system</p>"}]}